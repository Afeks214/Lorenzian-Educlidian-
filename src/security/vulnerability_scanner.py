"""
Comprehensive Vulnerability Scanner
Automated security scanning and remediation for CI/CD pipeline
"""

import os
import json
import asyncio
import subprocess
import tempfile
import shutil
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Set
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum
import yaml
import requests
from concurrent.futures import ThreadPoolExecutor

from src.monitoring.logger_config import get_logger
from src.config.secrets_manager import SecretsManager

logger = get_logger(__name__)

class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class ScannerType(Enum):
    """Types of security scanners"""
    STATIC_CODE = "static_code"
    DEPENDENCY = "dependency"
    CONTAINER = "container"
    SECRETS = "secrets"
    INFRASTRUCTURE = "infrastructure"
    WEB_APPLICATION = "web_application"
    NETWORK = "network"

@dataclass
class Vulnerability:
    """Vulnerability finding"""
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    scanner_type: ScannerType
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    remediation: Optional[str] = None
    references: List[str] = field(default_factory=list)
    first_detected: Optional[datetime] = None
    last_detected: Optional[datetime] = None
    status: str = "open"  # open, fixed, false_positive, accepted
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "severity": self.severity.value,
            "scanner_type": self.scanner_type.value,
            "file_path": self.file_path,
            "line_number": self.line_number,
            "cwe_id": self.cwe_id,
            "cvss_score": self.cvss_score,
            "remediation": self.remediation,
            "references": self.references,
            "first_detected": self.first_detected.isoformat() if self.first_detected else None,
            "last_detected": self.last_detected.isoformat() if self.last_detected else None,
            "status": self.status
        }

@dataclass
class ScanResult:
    """Security scan result"""
    scanner_type: ScannerType
    scan_id: str
    timestamp: datetime
    vulnerabilities: List[Vulnerability]
    scan_duration: float
    files_scanned: int
    status: str = "completed"
    error_message: Optional[str] = None
    
    def get_vulnerability_count_by_severity(self) -> Dict[str, int]:
        """Get count of vulnerabilities by severity"""
        counts = {severity.value: 0 for severity in VulnerabilitySeverity}
        for vuln in self.vulnerabilities:
            counts[vuln.severity.value] += 1
        return counts

class ComprehensiveVulnerabilityScanner:
    """Comprehensive vulnerability scanner for CI/CD integration"""
    
    def __init__(self, project_root: str = None):
        self.project_root = Path(project_root or os.getcwd())
        self.secrets_manager = SecretsManager()
        self.scan_results: List[ScanResult] = []
        self.vulnerability_db: Dict[str, Vulnerability] = {}
        
        # Scanner configurations
        self.scanner_configs = {
            ScannerType.STATIC_CODE: {
                "tools": ["bandit", "semgrep", "pylint"],
                "enabled": True,
                "timeout": 300
            },
            ScannerType.DEPENDENCY: {
                "tools": ["safety", "pip-audit", "snyk"],
                "enabled": True,
                "timeout": 180
            },
            ScannerType.CONTAINER: {
                "tools": ["trivy", "grype", "clair"],
                "enabled": True,
                "timeout": 240
            },
            ScannerType.SECRETS: {
                "tools": ["truffleHog", "detect-secrets", "gitleaks"],
                "enabled": True,
                "timeout": 120
            },
            ScannerType.INFRASTRUCTURE: {
                "tools": ["checkov", "tfsec", "terrascan"],
                "enabled": True,
                "timeout": 180
            },
            ScannerType.WEB_APPLICATION: {
                "tools": ["zap", "nikto", "sqlmap"],
                "enabled": False,  # Requires running application
                "timeout": 600
            },
            ScannerType.NETWORK: {
                "tools": ["nmap", "masscan"],
                "enabled": False,  # Requires network access
                "timeout": 300
            }
        }
        
        # Severity thresholds for CI/CD
        self.failure_thresholds = {
            VulnerabilitySeverity.CRITICAL: 0,  # Fail on any critical
            VulnerabilitySeverity.HIGH: 5,     # Fail on more than 5 high
            VulnerabilitySeverity.MEDIUM: 20,  # Fail on more than 20 medium
            VulnerabilitySeverity.LOW: 50      # Fail on more than 50 low
        }
        
        self.executor = ThreadPoolExecutor(max_workers=4)
        
        logger.info("ComprehensiveVulnerabilityScanner initialized")
    
    async def run_comprehensive_scan(self, 
                                   scan_types: List[ScannerType] = None,
                                   fail_on_vulnerabilities: bool = True) -> Dict[str, Any]:
        """Run comprehensive security scan"""
        scan_id = f"scan_{int(datetime.now().timestamp())}"
        start_time = datetime.now()
        
        logger.info(f"Starting comprehensive security scan: {scan_id}")
        
        # Default to all enabled scanners
        if scan_types is None:
            scan_types = [scanner for scanner, config in self.scanner_configs.items() 
                         if config["enabled"]]
        
        # Run scans in parallel
        scan_tasks = []
        for scanner_type in scan_types:
            task = asyncio.create_task(self._run_scanner(scanner_type, scan_id))
            scan_tasks.append(task)
        
        # Wait for all scans to complete
        scan_results = await asyncio.gather(*scan_tasks, return_exceptions=True)
        
        # Process results
        all_vulnerabilities = []
        successful_scans = []
        failed_scans = []
        
        for result in scan_results:
            if isinstance(result, Exception):
                logger.error(f"Scan failed: {result}")
                failed_scans.append(str(result))
            else:
                successful_scans.append(result)
                all_vulnerabilities.extend(result.vulnerabilities)
        
        # Update vulnerability database
        self._update_vulnerability_db(all_vulnerabilities)
        
        # Generate comprehensive report
        report = self._generate_scan_report(scan_id, successful_scans, failed_scans)
        
        # Check failure thresholds
        should_fail = self._check_failure_thresholds(all_vulnerabilities)
        
        scan_duration = (datetime.now() - start_time).total_seconds()
        
        logger.info(f"Comprehensive scan completed in {scan_duration:.2f}s",
                   vulnerabilities=len(all_vulnerabilities),
                   failed_scans=len(failed_scans))
        
        if fail_on_vulnerabilities and should_fail:
            raise RuntimeError(f"Security scan failed - vulnerabilities exceed thresholds")
        
        return report
    
    async def _run_scanner(self, scanner_type: ScannerType, scan_id: str) -> ScanResult:
        """Run specific scanner type"""
        start_time = datetime.now()
        config = self.scanner_configs[scanner_type]
        
        logger.info(f"Running {scanner_type.value} scan")
        
        vulnerabilities = []
        
        # Run each tool for this scanner type
        for tool in config["tools"]:
            try:
                tool_vulnerabilities = await self._run_tool(tool, scanner_type, config["timeout"])
                vulnerabilities.extend(tool_vulnerabilities)
            except Exception as e:
                logger.error(f"Tool {tool} failed: {e}")
        
        scan_duration = (datetime.now() - start_time).total_seconds()
        
        result = ScanResult(
            scanner_type=scanner_type,
            scan_id=scan_id,
            timestamp=datetime.now(),
            vulnerabilities=vulnerabilities,
            scan_duration=scan_duration,
            files_scanned=self._count_files_scanned(scanner_type)
        )
        
        self.scan_results.append(result)
        return result
    
    async def _run_tool(self, tool: str, scanner_type: ScannerType, timeout: int) -> List[Vulnerability]:
        """Run specific security tool"""
        vulnerabilities = []
        
        try:
            if tool == "bandit":
                vulnerabilities = await self._run_bandit()
            elif tool == "semgrep":
                vulnerabilities = await self._run_semgrep()
            elif tool == "safety":
                vulnerabilities = await self._run_safety()
            elif tool == "pip-audit":
                vulnerabilities = await self._run_pip_audit()
            elif tool == "trivy":
                vulnerabilities = await self._run_trivy()
            elif tool == "truffleHog":
                vulnerabilities = await self._run_trufflehog()
            elif tool == "detect-secrets":
                vulnerabilities = await self._run_detect_secrets()
            elif tool == "checkov":
                vulnerabilities = await self._run_checkov()
            else:
                logger.warning(f"Unknown tool: {tool}")
                
        except Exception as e:
            logger.error(f"Tool {tool} execution failed: {e}")
            
        return vulnerabilities
    
    async def _run_bandit(self) -> List[Vulnerability]:
        """Run Bandit static code analysis"""
        cmd = [
            "bandit", "-r", str(self.project_root / "src"),
            "-f", "json",
            "-ll",  # Low confidence threshold
            "-x", "tests/"
        ]
        
        result = await self._execute_command(cmd)
        
        if result["returncode"] == 0:
            return []  # No vulnerabilities found
        
        try:
            bandit_output = json.loads(result["stdout"])
            vulnerabilities = []
            
            for issue in bandit_output.get("results", []):
                vulnerability = Vulnerability(
                    id=f"bandit_{issue['test_id']}_{hash(issue['filename'] + str(issue['line_number']))}",
                    title=issue["issue_text"],
                    description=issue["issue_text"],
                    severity=self._map_bandit_severity(issue["issue_severity"]),
                    scanner_type=ScannerType.STATIC_CODE,
                    file_path=issue["filename"],
                    line_number=issue["line_number"],
                    cwe_id=issue.get("test_id"),
                    remediation=issue.get("more_info"),
                    first_detected=datetime.now(),
                    last_detected=datetime.now()
                )
                vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except json.JSONDecodeError:
            logger.error("Failed to parse Bandit output")
            return []
    
    async def _run_semgrep(self) -> List[Vulnerability]:
        """Run Semgrep static analysis"""
        cmd = [
            "semgrep", 
            "--config=auto",
            "--json",
            "--timeout=30",
            str(self.project_root / "src")
        ]
        
        result = await self._execute_command(cmd)
        
        if result["returncode"] != 0:
            logger.error(f"Semgrep failed: {result['stderr']}")
            return []
        
        try:
            semgrep_output = json.loads(result["stdout"])
            vulnerabilities = []
            
            for finding in semgrep_output.get("results", []):
                vulnerability = Vulnerability(
                    id=f"semgrep_{finding['check_id']}_{hash(finding['path'] + str(finding['start']['line']))}",
                    title=finding["message"],
                    description=finding["message"],
                    severity=self._map_semgrep_severity(finding.get("severity", "INFO")),
                    scanner_type=ScannerType.STATIC_CODE,
                    file_path=finding["path"],
                    line_number=finding["start"]["line"],
                    remediation=finding.get("fix"),
                    references=[finding.get("metadata", {}).get("source", "")],
                    first_detected=datetime.now(),
                    last_detected=datetime.now()
                )
                vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except json.JSONDecodeError:
            logger.error("Failed to parse Semgrep output")
            return []
    
    async def _run_safety(self) -> List[Vulnerability]:
        """Run Safety dependency scanner"""
        cmd = ["safety", "check", "--json", "--file", str(self.project_root / "requirements.txt")]
        
        result = await self._execute_command(cmd)
        
        if result["returncode"] == 0:
            return []  # No vulnerabilities found
        
        try:
            safety_output = json.loads(result["stdout"])
            vulnerabilities = []
            
            for vuln in safety_output:
                vulnerability = Vulnerability(
                    id=f"safety_{vuln['id']}",
                    title=f"Vulnerable dependency: {vuln['package_name']}",
                    description=vuln["advisory"],
                    severity=VulnerabilitySeverity.HIGH,  # All Safety findings are high
                    scanner_type=ScannerType.DEPENDENCY,
                    cwe_id=vuln.get("cwe"),
                    remediation=f"Upgrade {vuln['package_name']} to version {vuln.get('fixed_in', 'latest')}",
                    references=[vuln.get("more_info_url", "")],
                    first_detected=datetime.now(),
                    last_detected=datetime.now()
                )
                vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except json.JSONDecodeError:
            logger.error("Failed to parse Safety output")
            return []
    
    async def _run_pip_audit(self) -> List[Vulnerability]:
        """Run pip-audit dependency scanner"""
        cmd = ["pip-audit", "--format=json", "--requirement", str(self.project_root / "requirements.txt")]
        
        result = await self._execute_command(cmd)
        
        if result["returncode"] == 0:
            return []  # No vulnerabilities found
        
        try:
            audit_output = json.loads(result["stdout"])
            vulnerabilities = []
            
            for vuln in audit_output.get("vulnerabilities", []):
                vulnerability = Vulnerability(
                    id=f"pip_audit_{vuln['id']}",
                    title=f"Vulnerable dependency: {vuln['package']['name']}",
                    description=vuln["description"],
                    severity=VulnerabilitySeverity.HIGH,
                    scanner_type=ScannerType.DEPENDENCY,
                    remediation=f"Upgrade {vuln['package']['name']} from {vuln['package']['version']} to {vuln.get('fix_versions', ['latest'])[0]}",
                    references=[vuln.get("link", "")],
                    first_detected=datetime.now(),
                    last_detected=datetime.now()
                )
                vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except json.JSONDecodeError:
            logger.error("Failed to parse pip-audit output")
            return []
    
    async def _run_trivy(self) -> List[Vulnerability]:
        """Run Trivy container scanner"""
        # Check if Docker is available
        if not shutil.which("docker"):
            logger.warning("Docker not available, skipping Trivy scan")
            return []
        
        cmd = [
            "trivy", "fs", 
            "--format", "json",
            "--severity", "HIGH,CRITICAL",
            str(self.project_root)
        ]
        
        result = await self._execute_command(cmd)
        
        if result["returncode"] != 0:
            logger.error(f"Trivy failed: {result['stderr']}")
            return []
        
        try:
            trivy_output = json.loads(result["stdout"])
            vulnerabilities = []
            
            for target in trivy_output.get("Results", []):
                for vuln in target.get("Vulnerabilities", []):
                    vulnerability = Vulnerability(
                        id=f"trivy_{vuln['VulnerabilityID']}",
                        title=vuln["Title"],
                        description=vuln["Description"],
                        severity=self._map_trivy_severity(vuln["Severity"]),
                        scanner_type=ScannerType.CONTAINER,
                        cvss_score=vuln.get("CVSS", {}).get("nvd", {}).get("V3Score"),
                        remediation=vuln.get("FixedVersion"),
                        references=vuln.get("References", []),
                        first_detected=datetime.now(),
                        last_detected=datetime.now()
                    )
                    vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except json.JSONDecodeError:
            logger.error("Failed to parse Trivy output")
            return []
    
    async def _run_trufflehog(self) -> List[Vulnerability]:
        """Run TruffleHog secrets scanner"""
        cmd = [
            "trufflehog", "filesystem",
            "--json",
            "--no-verification",
            str(self.project_root)
        ]
        
        result = await self._execute_command(cmd)
        
        if result["returncode"] != 0:
            logger.error(f"TruffleHog failed: {result['stderr']}")
            return []
        
        vulnerabilities = []
        
        # Parse line-by-line JSON output
        for line in result["stdout"].strip().split("\n"):
            if not line:
                continue
            
            try:
                finding = json.loads(line)
                vulnerability = Vulnerability(
                    id=f"trufflehog_{finding['DetectorName']}_{hash(finding['Raw'])}",
                    title=f"Secret detected: {finding['DetectorName']}",
                    description=f"Potential secret found: {finding['DetectorName']}",
                    severity=VulnerabilitySeverity.HIGH,
                    scanner_type=ScannerType.SECRETS,
                    file_path=finding.get("SourceMetadata", {}).get("Data", {}).get("Filesystem", {}).get("file"),
                    line_number=finding.get("SourceMetadata", {}).get("Data", {}).get("Filesystem", {}).get("line"),
                    remediation="Remove or encrypt the secret",
                    first_detected=datetime.now(),
                    last_detected=datetime.now()
                )
                vulnerabilities.append(vulnerability)
                
            except json.JSONDecodeError:
                continue
        
        return vulnerabilities
    
    async def _run_detect_secrets(self) -> List[Vulnerability]:
        """Run detect-secrets scanner"""
        cmd = [
            "detect-secrets", "scan",
            "--all-files",
            "--force-use-all-plugins",
            str(self.project_root)
        ]
        
        result = await self._execute_command(cmd)
        
        if result["returncode"] != 0:
            logger.error(f"detect-secrets failed: {result['stderr']}")
            return []
        
        try:
            secrets_output = json.loads(result["stdout"])
            vulnerabilities = []
            
            for file_path, secrets in secrets_output.get("results", {}).items():
                for secret in secrets:
                    vulnerability = Vulnerability(
                        id=f"detect_secrets_{secret['type']}_{hash(file_path + str(secret['line_number']))}",
                        title=f"Secret detected: {secret['type']}",
                        description=f"Potential {secret['type']} secret found",
                        severity=VulnerabilitySeverity.HIGH,
                        scanner_type=ScannerType.SECRETS,
                        file_path=file_path,
                        line_number=secret["line_number"],
                        remediation="Remove or encrypt the secret",
                        first_detected=datetime.now(),
                        last_detected=datetime.now()
                    )
                    vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except json.JSONDecodeError:
            logger.error("Failed to parse detect-secrets output")
            return []
    
    async def _run_checkov(self) -> List[Vulnerability]:
        """Run Checkov infrastructure scanner"""
        cmd = [
            "checkov",
            "-d", str(self.project_root),
            "--framework", "dockerfile,terraform,kubernetes",
            "-o", "json",
            "--quiet"
        ]
        
        result = await self._execute_command(cmd)
        
        if result["returncode"] != 0:
            logger.error(f"Checkov failed: {result['stderr']}")
            return []
        
        try:
            checkov_output = json.loads(result["stdout"])
            vulnerabilities = []
            
            for check in checkov_output.get("results", {}).get("failed_checks", []):
                vulnerability = Vulnerability(
                    id=f"checkov_{check['check_id']}",
                    title=check["check_name"],
                    description=check["description"],
                    severity=self._map_checkov_severity(check.get("severity", "MEDIUM")),
                    scanner_type=ScannerType.INFRASTRUCTURE,
                    file_path=check["file_path"],
                    line_number=check.get("file_line_range", [0])[0],
                    remediation=check.get("guideline"),
                    first_detected=datetime.now(),
                    last_detected=datetime.now()
                )
                vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except json.JSONDecodeError:
            logger.error("Failed to parse Checkov output")
            return []
    
    async def _execute_command(self, cmd: List[str], timeout: int = 300) -> Dict[str, Any]:
        """Execute shell command with timeout"""
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=self.project_root
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )
            
            return {
                "returncode": process.returncode,
                "stdout": stdout.decode('utf-8'),
                "stderr": stderr.decode('utf-8')
            }
            
        except asyncio.TimeoutError:
            process.kill()
            await process.wait()
            raise RuntimeError(f"Command timed out after {timeout} seconds")
        except Exception as e:
            raise RuntimeError(f"Command execution failed: {str(e)}")
    
    def _map_bandit_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Bandit severity to standard severity"""
        mapping = {
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW
        }
        return mapping.get(severity, VulnerabilitySeverity.MEDIUM)
    
    def _map_semgrep_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Semgrep severity to standard severity"""
        mapping = {
            "ERROR": VulnerabilitySeverity.HIGH,
            "WARNING": VulnerabilitySeverity.MEDIUM,
            "INFO": VulnerabilitySeverity.LOW
        }
        return mapping.get(severity, VulnerabilitySeverity.MEDIUM)
    
    def _map_trivy_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Trivy severity to standard severity"""
        mapping = {
            "CRITICAL": VulnerabilitySeverity.CRITICAL,
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW
        }
        return mapping.get(severity, VulnerabilitySeverity.MEDIUM)
    
    def _map_checkov_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Checkov severity to standard severity"""
        mapping = {
            "CRITICAL": VulnerabilitySeverity.CRITICAL,
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW
        }
        return mapping.get(severity, VulnerabilitySeverity.MEDIUM)
    
    def _count_files_scanned(self, scanner_type: ScannerType) -> int:
        """Count files scanned by scanner type"""
        if scanner_type == ScannerType.STATIC_CODE:
            return len(list(self.project_root.rglob("*.py")))
        elif scanner_type == ScannerType.DEPENDENCY:
            return 1  # requirements.txt
        elif scanner_type == ScannerType.CONTAINER:
            return len(list(self.project_root.rglob("Dockerfile*")))
        elif scanner_type == ScannerType.SECRETS:
            return len(list(self.project_root.rglob("*"))) - len(list(self.project_root.rglob(".*")))
        elif scanner_type == ScannerType.INFRASTRUCTURE:
            return len(list(self.project_root.rglob("*.tf"))) + len(list(self.project_root.rglob("*.yaml")))
        else:
            return 0
    
    def _update_vulnerability_db(self, vulnerabilities: List[Vulnerability]):
        """Update vulnerability database with new findings"""
        for vuln in vulnerabilities:
            if vuln.id in self.vulnerability_db:
                # Update existing vulnerability
                existing = self.vulnerability_db[vuln.id]
                existing.last_detected = datetime.now()
                existing.status = "open"  # Reset status if found again
            else:
                # Add new vulnerability
                self.vulnerability_db[vuln.id] = vuln
    
    def _check_failure_thresholds(self, vulnerabilities: List[Vulnerability]) -> bool:
        """Check if vulnerabilities exceed failure thresholds"""
        severity_counts = {severity: 0 for severity in VulnerabilitySeverity}
        
        for vuln in vulnerabilities:
            severity_counts[vuln.severity] += 1
        
        for severity, threshold in self.failure_thresholds.items():
            if severity_counts[severity] > threshold:
                logger.error(f"Vulnerability threshold exceeded: {severity.value} = {severity_counts[severity]} > {threshold}")
                return True
        
        return False
    
    def _generate_scan_report(self, 
                            scan_id: str,
                            successful_scans: List[ScanResult],
                            failed_scans: List[str]) -> Dict[str, Any]:
        """Generate comprehensive scan report"""
        all_vulnerabilities = []
        for scan in successful_scans:
            all_vulnerabilities.extend(scan.vulnerabilities)
        
        # Calculate statistics
        severity_counts = {severity.value: 0 for severity in VulnerabilitySeverity}
        scanner_counts = {scanner.value: 0 for scanner in ScannerType}
        
        for vuln in all_vulnerabilities:
            severity_counts[vuln.severity.value] += 1
            scanner_counts[vuln.scanner_type.value] += 1
        
        # Generate report
        report = {
            "scan_id": scan_id,
            "timestamp": datetime.now().isoformat(),
            "summary": {
                "total_vulnerabilities": len(all_vulnerabilities),
                "successful_scans": len(successful_scans),
                "failed_scans": len(failed_scans),
                "severity_breakdown": severity_counts,
                "scanner_breakdown": scanner_counts
            },
            "scan_results": [
                {
                    "scanner_type": scan.scanner_type.value,
                    "scan_duration": scan.scan_duration,
                    "files_scanned": scan.files_scanned,
                    "vulnerabilities_found": len(scan.vulnerabilities),
                    "severity_breakdown": scan.get_vulnerability_count_by_severity()
                }
                for scan in successful_scans
            ],
            "vulnerabilities": [vuln.to_dict() for vuln in all_vulnerabilities],
            "failed_scans": failed_scans,
            "failure_thresholds": {severity.value: threshold for severity, threshold in self.failure_thresholds.items()},
            "exceeds_thresholds": self._check_failure_thresholds(all_vulnerabilities)
        }
        
        return report
    
    def generate_remediation_plan(self, vulnerabilities: List[Vulnerability] = None) -> Dict[str, Any]:
        """Generate automated remediation plan"""
        if vulnerabilities is None:
            vulnerabilities = list(self.vulnerability_db.values())
        
        # Group vulnerabilities by remediation type
        remediation_plan = {
            "dependency_updates": [],
            "code_fixes": [],
            "configuration_changes": [],
            "manual_review": []
        }
        
        for vuln in vulnerabilities:
            if vuln.scanner_type == ScannerType.DEPENDENCY:
                remediation_plan["dependency_updates"].append({
                    "vulnerability_id": vuln.id,
                    "package": vuln.file_path,
                    "remediation": vuln.remediation,
                    "severity": vuln.severity.value
                })
            elif vuln.scanner_type == ScannerType.STATIC_CODE:
                remediation_plan["code_fixes"].append({
                    "vulnerability_id": vuln.id,
                    "file": vuln.file_path,
                    "line": vuln.line_number,
                    "remediation": vuln.remediation,
                    "severity": vuln.severity.value
                })
            elif vuln.scanner_type == ScannerType.INFRASTRUCTURE:
                remediation_plan["configuration_changes"].append({
                    "vulnerability_id": vuln.id,
                    "file": vuln.file_path,
                    "remediation": vuln.remediation,
                    "severity": vuln.severity.value
                })
            else:
                remediation_plan["manual_review"].append({
                    "vulnerability_id": vuln.id,
                    "type": vuln.scanner_type.value,
                    "remediation": vuln.remediation,
                    "severity": vuln.severity.value
                })
        
        return remediation_plan
    
    def get_vulnerability_trends(self, days: int = 30) -> Dict[str, Any]:
        """Get vulnerability trends over time"""
        cutoff_date = datetime.now() - timedelta(days=days)
        
        # Filter vulnerabilities by date
        recent_vulnerabilities = [
            vuln for vuln in self.vulnerability_db.values()
            if vuln.first_detected and vuln.first_detected >= cutoff_date
        ]
        
        # Calculate trends
        trends = {
            "total_vulnerabilities": len(self.vulnerability_db),
            "new_vulnerabilities": len(recent_vulnerabilities),
            "fixed_vulnerabilities": len([
                vuln for vuln in self.vulnerability_db.values()
                if vuln.status == "fixed"
            ]),
            "severity_trends": {}
        }
        
        # Calculate severity trends
        for severity in VulnerabilitySeverity:
            trends["severity_trends"][severity.value] = {
                "total": len([
                    vuln for vuln in self.vulnerability_db.values()
                    if vuln.severity == severity
                ]),
                "new": len([
                    vuln for vuln in recent_vulnerabilities
                    if vuln.severity == severity
                ])
            }
        
        return trends

# Factory function
def create_vulnerability_scanner(project_root: str = None) -> ComprehensiveVulnerabilityScanner:
    """Create vulnerability scanner instance"""
    return ComprehensiveVulnerabilityScanner(project_root)

# CLI interface
async def main():
    """CLI for vulnerability scanner"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Comprehensive Vulnerability Scanner")
    parser.add_argument("--project-root", help="Project root directory")
    parser.add_argument("--scan-types", nargs="*", help="Scan types to run")
    parser.add_argument("--fail-on-vulnerabilities", action="store_true", help="Fail on vulnerabilities")
    parser.add_argument("--output", help="Output file for report")
    
    args = parser.parse_args()
    
    scanner = create_vulnerability_scanner(args.project_root)
    
    # Parse scan types
    scan_types = None
    if args.scan_types:
        scan_types = [ScannerType(scan_type) for scan_type in args.scan_types]
    
    try:
        report = await scanner.run_comprehensive_scan(
            scan_types=scan_types,
            fail_on_vulnerabilities=args.fail_on_vulnerabilities
        )
        
        # Save report
        if args.output:
            with open(args.output, 'w') as f:
                json.dump(report, f, indent=2)
            print(f"Report saved to {args.output}")
        else:
            print(json.dumps(report, indent=2))
        
        # Print summary
        print(f"\nğŸ” Scan Summary:")
        print(f"  Total vulnerabilities: {report['summary']['total_vulnerabilities']}")
        print(f"  Critical: {report['summary']['severity_breakdown']['critical']}")
        print(f"  High: {report['summary']['severity_breakdown']['high']}")
        print(f"  Medium: {report['summary']['severity_breakdown']['medium']}")
        print(f"  Low: {report['summary']['severity_breakdown']['low']}")
        
        if report["summary"]["total_vulnerabilities"] > 0:
            print(f"\nâš ï¸  Vulnerabilities found - review the report for details")
        else:
            print(f"\nâœ… No vulnerabilities found")
            
    except Exception as e:
        print(f"âŒ Scan failed: {str(e)}")
        exit(1)

if __name__ == "__main__":
    asyncio.run(main())
