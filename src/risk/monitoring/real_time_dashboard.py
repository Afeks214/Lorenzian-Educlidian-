"""
Real-Time Risk Monitoring Dashboard

This module provides comprehensive real-time risk monitoring capabilities including:
- Live risk metrics tracking
- Automated alert generation
- Risk limit monitoring
- Performance dashboards
- Regulatory compliance monitoring

Author: Agent 16 - Risk Management Enhancement Specialist
Mission: Implement production-ready real-time risk monitoring
"""

import asyncio
import time
from typing import Dict, List, Optional, Callable, Any, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import json
import numpy as np
import pandas as pd
from collections import deque, defaultdict
import structlog
from pathlib import Path

logger = structlog.get_logger()


class AlertSeverity(Enum):
    """Alert severity levels"""
    INFO = "INFO"
    WARNING = "WARNING"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"


class RiskMetricType(Enum):
    """Types of risk metrics to monitor"""
    VAR = "var"
    EXPECTED_SHORTFALL = "expected_shortfall"
    CORRELATION = "correlation"
    VOLATILITY = "volatility"
    CONCENTRATION = "concentration"
    LEVERAGE = "leverage"
    LIQUIDITY = "liquidity"
    DRAWDOWN = "drawdown"
    KELLY_FRACTION = "kelly_fraction"
    BETA = "beta"


@dataclass
class RiskAlert:
    """Risk alert notification"""
    alert_id: str
    timestamp: datetime
    severity: AlertSeverity
    metric_type: RiskMetricType
    metric_name: str
    current_value: float
    threshold_value: float
    breach_magnitude: float
    portfolio_impact: str
    recommended_action: str
    auto_actions_triggered: List[str] = field(default_factory=list)
    acknowledged: bool = False
    resolved: bool = False
    resolution_time: Optional[datetime] = None


@dataclass
class RiskLimit:
    """Risk limit configuration"""
    limit_id: str
    metric_type: RiskMetricType
    metric_name: str
    warning_threshold: float
    critical_threshold: float
    enabled: bool = True
    auto_actions: List[str] = field(default_factory=list)
    notification_channels: List[str] = field(default_factory=list)


@dataclass
class DashboardMetrics:
    """Real-time dashboard metrics"""
    timestamp: datetime
    portfolio_value: float
    portfolio_var_95: float
    portfolio_var_99: float
    expected_shortfall: float
    max_drawdown: float
    current_leverage: float
    correlation_regime: str
    active_alerts: int
    performance_metrics: Dict[str, float]
    risk_attribution: Dict[str, float]
    concentration_metrics: Dict[str, float]


class RealTimeRiskMonitor:
    """
    Real-time risk monitoring system with automated alerting and dashboards.
    
    Features:
    - Continuous risk metrics monitoring
    - Automated alert generation
    - Risk limit enforcement
    - Performance dashboards
    - Historical trend analysis
    """
    
    def __init__(
        self,
        update_interval_seconds: int = 30,
        alert_retention_days: int = 30,
        metrics_retention_days: int = 7,
        enable_auto_actions: bool = True
    ):
        self.update_interval = update_interval_seconds
        self.alert_retention_days = alert_retention_days
        self.metrics_retention_days = metrics_retention_days
        self.enable_auto_actions = enable_auto_actions
        
        # Risk limits configuration
        self.risk_limits: Dict[str, RiskLimit] = {}
        self._setup_default_risk_limits()
        
        # Alert system
        self.active_alerts: Dict[str, RiskAlert] = {}
        self.alert_history: deque = deque(maxlen=10000)\n        self.alert_callbacks: List[Callable] = []\n        \n        # Metrics storage\n        self.metrics_history: deque = deque(maxlen=10000)\n        self.current_metrics: Optional[DashboardMetrics] = None\n        \n        # Monitoring state\n        self.monitoring_active = False\n        self.monitoring_task: Optional[asyncio.Task] = None\n        \n        # Performance tracking\n        self.update_times: deque = deque(maxlen=1000)\n        self.last_update_time: Optional[datetime] = None\n        \n        # Auto-action system\n        self.auto_actions: Dict[str, Callable] = {}\n        self._setup_default_auto_actions()\n        \n        # Notification channels\n        self.notification_channels: Dict[str, Callable] = {}\n        \n        logger.info(\"RealTimeRiskMonitor initialized\",\n                   update_interval=update_interval_seconds,\n                   alert_retention_days=alert_retention_days,\n                   enable_auto_actions=enable_auto_actions)\n    \n    def _setup_default_risk_limits(self):\n        \"\"\"Setup default risk limits\"\"\"\n        \n        # VaR limits\n        self.risk_limits[\"var_95_daily\"] = RiskLimit(\n            limit_id=\"var_95_daily\",\n            metric_type=RiskMetricType.VAR,\n            metric_name=\"portfolio_var_95\",\n            warning_threshold=0.02,  # 2% of portfolio\n            critical_threshold=0.05,  # 5% of portfolio\n            auto_actions=[\"reduce_leverage\", \"notify_risk_manager\"],\n            notification_channels=[\"email\", \"slack\"]\n        )\n        \n        self.risk_limits[\"var_99_daily\"] = RiskLimit(\n            limit_id=\"var_99_daily\",\n            metric_type=RiskMetricType.VAR,\n            metric_name=\"portfolio_var_99\",\n            warning_threshold=0.03,  # 3% of portfolio\n            critical_threshold=0.08,  # 8% of portfolio\n            auto_actions=[\"reduce_leverage\", \"emergency_stop\"],\n            notification_channels=[\"email\", \"slack\", \"sms\"]\n        )\n        \n        # Expected Shortfall limits\n        self.risk_limits[\"expected_shortfall\"] = RiskLimit(\n            limit_id=\"expected_shortfall\",\n            metric_type=RiskMetricType.EXPECTED_SHORTFALL,\n            metric_name=\"expected_shortfall\",\n            warning_threshold=0.06,  # 6% of portfolio\n            critical_threshold=0.12,  # 12% of portfolio\n            auto_actions=[\"reduce_leverage\"],\n            notification_channels=[\"email\", \"slack\"]\n        )\n        \n        # Leverage limits\n        self.risk_limits[\"leverage\"] = RiskLimit(\n            limit_id=\"leverage\",\n            metric_type=RiskMetricType.LEVERAGE,\n            metric_name=\"current_leverage\",\n            warning_threshold=3.0,  # 3x leverage\n            critical_threshold=4.0,  # 4x leverage\n            auto_actions=[\"reduce_leverage\"],\n            notification_channels=[\"email\", \"slack\"]\n        )\n        \n        # Drawdown limits\n        self.risk_limits[\"max_drawdown\"] = RiskLimit(\n            limit_id=\"max_drawdown\",\n            metric_type=RiskMetricType.DRAWDOWN,\n            metric_name=\"max_drawdown\",\n            warning_threshold=0.10,  # 10% drawdown\n            critical_threshold=0.20,  # 20% drawdown\n            auto_actions=[\"reduce_leverage\", \"emergency_stop\"],\n            notification_channels=[\"email\", \"slack\", \"sms\"]\n        )\n        \n        # Concentration limits\n        self.risk_limits[\"concentration\"] = RiskLimit(\n            limit_id=\"concentration\",\n            metric_type=RiskMetricType.CONCENTRATION,\n            metric_name=\"max_position_concentration\",\n            warning_threshold=0.15,  # 15% in single position\n            critical_threshold=0.25,  # 25% in single position\n            auto_actions=[\"rebalance_portfolio\"],\n            notification_channels=[\"email\"]\n        )\n    \n    def _setup_default_auto_actions(self):\n        \"\"\"Setup default automated actions\"\"\"\n        \n        self.auto_actions[\"reduce_leverage\"] = self._reduce_leverage_action\n        self.auto_actions[\"emergency_stop\"] = self._emergency_stop_action\n        self.auto_actions[\"rebalance_portfolio\"] = self._rebalance_portfolio_action\n        self.auto_actions[\"notify_risk_manager\"] = self._notify_risk_manager_action\n    \n    async def start_monitoring(self):\n        \"\"\"Start real-time risk monitoring\"\"\"\n        if self.monitoring_active:\n            logger.warning(\"Risk monitoring already active\")\n            return\n        \n        self.monitoring_active = True\n        self.monitoring_task = asyncio.create_task(self._monitoring_loop())\n        \n        logger.info(\"Real-time risk monitoring started\")\n    \n    async def stop_monitoring(self):\n        \"\"\"Stop real-time risk monitoring\"\"\"\n        if not self.monitoring_active:\n            return\n        \n        self.monitoring_active = False\n        \n        if self.monitoring_task:\n            self.monitoring_task.cancel()\n            try:\n                await self.monitoring_task\n            except asyncio.CancelledError:\n                pass\n        \n        logger.info(\"Real-time risk monitoring stopped\")\n    \n    async def _monitoring_loop(self):\n        \"\"\"Main monitoring loop\"\"\"\n        while self.monitoring_active:\n            try:\n                start_time = time.time()\n                \n                # Update risk metrics\n                await self._update_risk_metrics()\n                \n                # Check risk limits\n                await self._check_risk_limits()\n                \n                # Clean up old data\n                self._cleanup_old_data()\n                \n                # Record update time\n                update_time = time.time() - start_time\n                self.update_times.append(update_time)\n                self.last_update_time = datetime.now()\n                \n                # Wait for next update\n                await asyncio.sleep(self.update_interval)\n                \n            except Exception as e:\n                logger.error(\"Error in monitoring loop\", error=str(e))\n                await asyncio.sleep(self.update_interval)\n    \n    async def _update_risk_metrics(self):\n        \"\"\"Update current risk metrics\"\"\"\n        # This would integrate with the actual risk calculation systems\n        # For now, we'll create placeholder metrics\n        \n        # In a real implementation, this would call:\n        # - VaR calculator\n        # - Correlation tracker\n        # - Risk attribution analyzer\n        # - Portfolio manager\n        \n        current_time = datetime.now()\n        \n        # Placeholder metrics (would be replaced with actual calculations)\n        metrics = DashboardMetrics(\n            timestamp=current_time,\n            portfolio_value=1000000.0,  # $1M portfolio\n            portfolio_var_95=15000.0,   # $15K VaR at 95%\n            portfolio_var_99=25000.0,   # $25K VaR at 99%\n            expected_shortfall=35000.0,  # $35K ES\n            max_drawdown=0.08,          # 8% drawdown\n            current_leverage=2.5,       # 2.5x leverage\n            correlation_regime=\"NORMAL\",\n            active_alerts=len(self.active_alerts),\n            performance_metrics={\n                \"sharpe_ratio\": 1.8,\n                \"sortino_ratio\": 2.1,\n                \"calmar_ratio\": 1.5,\n                \"max_drawdown_duration_days\": 15\n            },\n            risk_attribution={\n                \"market_risk\": 0.7,\n                \"specific_risk\": 0.3,\n                \"concentration_risk\": 0.15\n            },\n            concentration_metrics={\n                \"max_position_weight\": 0.12,\n                \"effective_positions\": 8.3,\n                \"herfindahl_index\": 0.18\n            }\n        )\n        \n        self.current_metrics = metrics\n        self.metrics_history.append(metrics)\n        \n        logger.debug(\"Risk metrics updated\",\n                    timestamp=current_time,\n                    portfolio_value=metrics.portfolio_value,\n                    var_95=metrics.portfolio_var_95)\n    \n    async def _check_risk_limits(self):\n        \"\"\"Check all risk limits and generate alerts\"\"\"\n        if not self.current_metrics:\n            return\n        \n        for limit_id, risk_limit in self.risk_limits.items():\n            if not risk_limit.enabled:\n                continue\n            \n            # Get current metric value\n            current_value = self._get_metric_value(risk_limit.metric_name)\n            if current_value is None:\n                continue\n            \n            # Check for breaches\n            await self._check_limit_breach(risk_limit, current_value)\n    \n    def _get_metric_value(self, metric_name: str) -> Optional[float]:\n        \"\"\"Get current value of a risk metric\"\"\"\n        if not self.current_metrics:\n            return None\n        \n        # Handle special metric names\n        if metric_name == \"portfolio_var_95_pct\":\n            return self.current_metrics.portfolio_var_95 / self.current_metrics.portfolio_value\n        elif metric_name == \"portfolio_var_99_pct\":\n            return self.current_metrics.portfolio_var_99 / self.current_metrics.portfolio_value\n        elif metric_name == \"expected_shortfall_pct\":\n            return self.current_metrics.expected_shortfall / self.current_metrics.portfolio_value\n        elif metric_name == \"max_position_concentration\":\n            return self.current_metrics.concentration_metrics.get(\"max_position_weight\", 0)\n        \n        # Direct attribute access\n        return getattr(self.current_metrics, metric_name, None)\n    \n    async def _check_limit_breach(self, risk_limit: RiskLimit, current_value: float):\n        \"\"\"Check if a risk limit has been breached\"\"\"\n        \n        alert_id = f\"{risk_limit.limit_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        \n        # Check critical threshold\n        if current_value >= risk_limit.critical_threshold:\n            await self._generate_alert(\n                alert_id=alert_id,\n                severity=AlertSeverity.CRITICAL,\n                risk_limit=risk_limit,\n                current_value=current_value,\n                threshold_value=risk_limit.critical_threshold\n            )\n        \n        # Check warning threshold\n        elif current_value >= risk_limit.warning_threshold:\n            await self._generate_alert(\n                alert_id=alert_id,\n                severity=AlertSeverity.WARNING,\n                risk_limit=risk_limit,\n                current_value=current_value,\n                threshold_value=risk_limit.warning_threshold\n            )\n    \n    async def _generate_alert(\n        self,\n        alert_id: str,\n        severity: AlertSeverity,\n        risk_limit: RiskLimit,\n        current_value: float,\n        threshold_value: float\n    ):\n        \"\"\"Generate a risk alert\"\"\"\n        \n        # Check if similar alert already exists\n        similar_alert = self._find_similar_active_alert(risk_limit.limit_id)\n        if similar_alert:\n            # Update existing alert\n            similar_alert.current_value = current_value\n            similar_alert.breach_magnitude = current_value - threshold_value\n            similar_alert.timestamp = datetime.now()\n            return\n        \n        # Create new alert\n        alert = RiskAlert(\n            alert_id=alert_id,\n            timestamp=datetime.now(),\n            severity=severity,\n            metric_type=risk_limit.metric_type,\n            metric_name=risk_limit.metric_name,\n            current_value=current_value,\n            threshold_value=threshold_value,\n            breach_magnitude=current_value - threshold_value,\n            portfolio_impact=self._assess_portfolio_impact(risk_limit, current_value),\n            recommended_action=self._generate_recommended_action(risk_limit, severity)\n        )\n        \n        # Store alert\n        self.active_alerts[alert_id] = alert\n        self.alert_history.append(alert)\n        \n        # Execute auto-actions if enabled\n        if self.enable_auto_actions and risk_limit.auto_actions:\n            await self._execute_auto_actions(alert, risk_limit.auto_actions)\n        \n        # Send notifications\n        await self._send_notifications(alert, risk_limit.notification_channels)\n        \n        # Call alert callbacks\n        for callback in self.alert_callbacks:\n            try:\n                await callback(alert)\n            except Exception as e:\n                logger.error(\"Error in alert callback\", error=str(e))\n        \n        logger.warning(\"Risk alert generated\",\n                      alert_id=alert_id,\n                      severity=severity.value,\n                      metric=risk_limit.metric_name,\n                      current_value=current_value,\n                      threshold=threshold_value)\n    \n    def _find_similar_active_alert(self, limit_id: str) -> Optional[RiskAlert]:\n        \"\"\"Find similar active alert for the same limit\"\"\"\n        for alert in self.active_alerts.values():\n            if not alert.resolved and limit_id in alert.alert_id:\n                return alert\n        return None\n    \n    def _assess_portfolio_impact(self, risk_limit: RiskLimit, current_value: float) -> str:\n        \"\"\"Assess the impact of the risk limit breach on the portfolio\"\"\"\n        \n        breach_magnitude = current_value - risk_limit.critical_threshold\n        \n        if risk_limit.metric_type == RiskMetricType.VAR:\n            if breach_magnitude > 0.03:  # 3% portfolio\n                return \"SEVERE: Significant potential loss exposure\"\n            elif breach_magnitude > 0.01:  # 1% portfolio\n                return \"MODERATE: Elevated loss risk\"\n            else:\n                return \"MILD: Minor risk increase\"\n        \n        elif risk_limit.metric_type == RiskMetricType.LEVERAGE:\n            if breach_magnitude > 1.0:  # 1x leverage\n                return \"SEVERE: Excessive leverage exposure\"\n            elif breach_magnitude > 0.5:  # 0.5x leverage\n                return \"MODERATE: High leverage risk\"\n            else:\n                return \"MILD: Slightly elevated leverage\"\n        \n        elif risk_limit.metric_type == RiskMetricType.DRAWDOWN:\n            if breach_magnitude > 0.1:  # 10% additional drawdown\n                return \"SEVERE: Substantial capital loss\"\n            elif breach_magnitude > 0.05:  # 5% additional drawdown\n                return \"MODERATE: Significant drawdown\"\n            else:\n                return \"MILD: Minor drawdown increase\"\n        \n        return \"UNKNOWN: Impact assessment unavailable\"\n    \n    def _generate_recommended_action(self, risk_limit: RiskLimit, severity: AlertSeverity) -> str:\n        \"\"\"Generate recommended action for the alert\"\"\"\n        \n        if severity == AlertSeverity.CRITICAL:\n            if risk_limit.metric_type == RiskMetricType.VAR:\n                return \"IMMEDIATE: Reduce position sizes and hedge exposure\"\n            elif risk_limit.metric_type == RiskMetricType.LEVERAGE:\n                return \"IMMEDIATE: Reduce leverage to below 3x\"\n            elif risk_limit.metric_type == RiskMetricType.DRAWDOWN:\n                return \"IMMEDIATE: Consider stopping trading and review strategy\"\n            else:\n                return \"IMMEDIATE: Review risk exposure and take corrective action\"\n        \n        elif severity == AlertSeverity.WARNING:\n            if risk_limit.metric_type == RiskMetricType.VAR:\n                return \"Monitor closely and prepare to reduce risk\"\n            elif risk_limit.metric_type == RiskMetricType.LEVERAGE:\n                return \"Consider reducing leverage proactively\"\n            elif risk_limit.metric_type == RiskMetricType.CONCENTRATION:\n                return \"Review position sizing and diversification\"\n            else:\n                return \"Monitor risk metric and prepare contingency actions\"\n        \n        return \"Monitor and assess situation\"\n    \n    async def _execute_auto_actions(self, alert: RiskAlert, actions: List[str]):\n        \"\"\"Execute automated actions for an alert\"\"\"\n        \n        executed_actions = []\n        \n        for action in actions:\n            if action in self.auto_actions:\n                try:\n                    await self.auto_actions[action](alert)\n                    executed_actions.append(action)\n                    logger.info(\"Auto-action executed\", action=action, alert_id=alert.alert_id)\n                except Exception as e:\n                    logger.error(\"Auto-action failed\", action=action, error=str(e))\n        \n        alert.auto_actions_triggered = executed_actions\n    \n    async def _send_notifications(self, alert: RiskAlert, channels: List[str]):\n        \"\"\"Send alert notifications through configured channels\"\"\"\n        \n        for channel in channels:\n            if channel in self.notification_channels:\n                try:\n                    await self.notification_channels[channel](alert)\n                    logger.info(\"Notification sent\", channel=channel, alert_id=alert.alert_id)\n                except Exception as e:\n                    logger.error(\"Notification failed\", channel=channel, error=str(e))\n    \n    async def _reduce_leverage_action(self, alert: RiskAlert):\n        \"\"\"Automated leverage reduction action\"\"\"\n        logger.info(\"Executing leverage reduction\", alert_id=alert.alert_id)\n        # Implementation would integrate with position management system\n        pass\n    \n    async def _emergency_stop_action(self, alert: RiskAlert):\n        \"\"\"Emergency stop action\"\"\"\n        logger.critical(\"Executing emergency stop\", alert_id=alert.alert_id)\n        # Implementation would stop all trading and close positions\n        pass\n    \n    async def _rebalance_portfolio_action(self, alert: RiskAlert):\n        \"\"\"Portfolio rebalancing action\"\"\"\n        logger.info(\"Executing portfolio rebalancing\", alert_id=alert.alert_id)\n        # Implementation would rebalance positions to target allocations\n        pass\n    \n    async def _notify_risk_manager_action(self, alert: RiskAlert):\n        \"\"\"Notify risk manager action\"\"\"\n        logger.info(\"Notifying risk manager\", alert_id=alert.alert_id)\n        # Implementation would send alert to risk management team\n        pass\n    \n    def _cleanup_old_data(self):\n        \"\"\"Clean up old alerts and metrics\"\"\"\n        \n        cutoff_time = datetime.now() - timedelta(days=self.alert_retention_days)\n        \n        # Remove old resolved alerts\n        alerts_to_remove = []\n        for alert_id, alert in self.active_alerts.items():\n            if alert.resolved and alert.resolution_time and alert.resolution_time < cutoff_time:\n                alerts_to_remove.append(alert_id)\n        \n        for alert_id in alerts_to_remove:\n            del self.active_alerts[alert_id]\n    \n    def get_dashboard_data(self) -> Dict:\n        \"\"\"Get current dashboard data\"\"\"\n        \n        if not self.current_metrics:\n            return {\"status\": \"No metrics available\"}\n        \n        # Recent alerts\n        recent_alerts = [\n            {\n                \"alert_id\": alert.alert_id,\n                \"timestamp\": alert.timestamp.isoformat(),\n                \"severity\": alert.severity.value,\n                \"metric\": alert.metric_name,\n                \"current_value\": alert.current_value,\n                \"threshold\": alert.threshold_value,\n                \"impact\": alert.portfolio_impact\n            }\n            for alert in sorted(self.active_alerts.values(), key=lambda x: x.timestamp, reverse=True)[:10]\n        ]\n        \n        # Performance metrics\n        avg_update_time = np.mean(self.update_times) if self.update_times else 0\n        \n        return {\n            \"timestamp\": self.current_metrics.timestamp.isoformat(),\n            \"monitoring_status\": \"ACTIVE\" if self.monitoring_active else \"INACTIVE\",\n            \"portfolio_summary\": {\n                \"value\": self.current_metrics.portfolio_value,\n                \"var_95\": self.current_metrics.portfolio_var_95,\n                \"var_99\": self.current_metrics.portfolio_var_99,\n                \"expected_shortfall\": self.current_metrics.expected_shortfall,\n                \"max_drawdown\": self.current_metrics.max_drawdown,\n                \"leverage\": self.current_metrics.current_leverage,\n                \"correlation_regime\": self.current_metrics.correlation_regime\n            },\n            \"risk_limits_status\": {\n                limit_id: {\n                    \"enabled\": limit.enabled,\n                    \"current_value\": self._get_metric_value(limit.metric_name),\n                    \"warning_threshold\": limit.warning_threshold,\n                    \"critical_threshold\": limit.critical_threshold,\n                    \"status\": self._get_limit_status(limit)\n                }\n                for limit_id, limit in self.risk_limits.items()\n            },\n            \"active_alerts\": recent_alerts,\n            \"performance_metrics\": self.current_metrics.performance_metrics,\n            \"risk_attribution\": self.current_metrics.risk_attribution,\n            \"concentration_metrics\": self.current_metrics.concentration_metrics,\n            \"system_performance\": {\n                \"avg_update_time_ms\": avg_update_time * 1000,\n                \"last_update\": self.last_update_time.isoformat() if self.last_update_time else None,\n                \"update_interval_seconds\": self.update_interval\n            }\n        }\n    \n    def _get_limit_status(self, limit: RiskLimit) -> str:\n        \"\"\"Get status of a risk limit\"\"\"\n        if not limit.enabled:\n            return \"DISABLED\"\n        \n        current_value = self._get_metric_value(limit.metric_name)\n        if current_value is None:\n            return \"UNKNOWN\"\n        \n        if current_value >= limit.critical_threshold:\n            return \"CRITICAL\"\n        elif current_value >= limit.warning_threshold:\n            return \"WARNING\"\n        else:\n            return \"NORMAL\"\n    \n    def register_alert_callback(self, callback: Callable[[RiskAlert], None]):\n        \"\"\"Register callback for alert notifications\"\"\"\n        self.alert_callbacks.append(callback)\n    \n    def register_notification_channel(self, channel_name: str, callback: Callable[[RiskAlert], None]):\n        \"\"\"Register notification channel\"\"\"\n        self.notification_channels[channel_name] = callback\n    \n    def acknowledge_alert(self, alert_id: str, operator_id: str) -> bool:\n        \"\"\"Acknowledge an alert\"\"\"\n        if alert_id in self.active_alerts:\n            self.active_alerts[alert_id].acknowledged = True\n            logger.info(\"Alert acknowledged\", alert_id=alert_id, operator=operator_id)\n            return True\n        return False\n    \n    def resolve_alert(self, alert_id: str, operator_id: str, resolution_note: str = \"\") -> bool:\n        \"\"\"Resolve an alert\"\"\"\n        if alert_id in self.active_alerts:\n            alert = self.active_alerts[alert_id]\n            alert.resolved = True\n            alert.resolution_time = datetime.now()\n            logger.info(\"Alert resolved\", alert_id=alert_id, operator=operator_id, note=resolution_note)\n            return True\n        return False\n    \n    def get_alert_history(self, hours: int = 24) -> List[Dict]:\n        \"\"\"Get alert history for specified time period\"\"\"\n        \n        cutoff_time = datetime.now() - timedelta(hours=hours)\n        \n        recent_alerts = [\n            {\n                \"alert_id\": alert.alert_id,\n                \"timestamp\": alert.timestamp.isoformat(),\n                \"severity\": alert.severity.value,\n                \"metric_type\": alert.metric_type.value,\n                \"metric_name\": alert.metric_name,\n                \"current_value\": alert.current_value,\n                \"threshold_value\": alert.threshold_value,\n                \"breach_magnitude\": alert.breach_magnitude,\n                \"portfolio_impact\": alert.portfolio_impact,\n                \"recommended_action\": alert.recommended_action,\n                \"auto_actions_triggered\": alert.auto_actions_triggered,\n                \"acknowledged\": alert.acknowledged,\n                \"resolved\": alert.resolved,\n                \"resolution_time\": alert.resolution_time.isoformat() if alert.resolution_time else None\n            }\n            for alert in self.alert_history\n            if alert.timestamp >= cutoff_time\n        ]\n        \n        return sorted(recent_alerts, key=lambda x: x[\"timestamp\"], reverse=True)\n    \n    def export_monitoring_data(self, hours: int = 24) -> Dict:\n        \"\"\"Export monitoring data for analysis\"\"\"\n        \n        cutoff_time = datetime.now() - timedelta(hours=hours)\n        \n        # Recent metrics\n        recent_metrics = [\n            {\n                \"timestamp\": metric.timestamp.isoformat(),\n                \"portfolio_value\": metric.portfolio_value,\n                \"portfolio_var_95\": metric.portfolio_var_95,\n                \"portfolio_var_99\": metric.portfolio_var_99,\n                \"expected_shortfall\": metric.expected_shortfall,\n                \"max_drawdown\": metric.max_drawdown,\n                \"current_leverage\": metric.current_leverage,\n                \"correlation_regime\": metric.correlation_regime,\n                \"active_alerts\": metric.active_alerts\n            }\n            for metric in self.metrics_history\n            if metric.timestamp >= cutoff_time\n        ]\n        \n        return {\n            \"export_timestamp\": datetime.now().isoformat(),\n            \"hours_exported\": hours,\n            \"metrics\": recent_metrics,\n            \"alerts\": self.get_alert_history(hours),\n            \"risk_limits\": {\n                limit_id: {\n                    \"metric_type\": limit.metric_type.value,\n                    \"metric_name\": limit.metric_name,\n                    \"warning_threshold\": limit.warning_threshold,\n                    \"critical_threshold\": limit.critical_threshold,\n                    \"enabled\": limit.enabled,\n                    \"auto_actions\": limit.auto_actions\n                }\n                for limit_id, limit in self.risk_limits.items()\n            },\n            \"system_performance\": {\n                \"avg_update_time_ms\": np.mean(self.update_times) * 1000 if self.update_times else 0,\n                \"total_updates\": len(self.update_times),\n                \"monitoring_active\": self.monitoring_active\n            }\n        }\n\n\n# Factory function for easy instantiation\ndef create_real_time_risk_monitor(\n    update_interval_seconds: int = 30,\n    enable_auto_actions: bool = True\n) -> RealTimeRiskMonitor:\n    \"\"\"Create a real-time risk monitor with default configuration\"\"\"\n    return RealTimeRiskMonitor(\n        update_interval_seconds=update_interval_seconds,\n        enable_auto_actions=enable_auto_actions\n    )