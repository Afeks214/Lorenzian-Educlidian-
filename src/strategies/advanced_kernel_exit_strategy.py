"""
Advanced Exit Strategy Using Kernel Regression Parameters

This module implements a sophisticated exit strategy for the Lorentzian Classification 
trading system using the r-factor and kernel regression parameters from the Nadaraya-Watson 
Rational Quadratic Kernel (NWRQK) implementation.

The strategy combines:
1. R-Factor dynamic adjustments based on market conditions
2. Quadratic regression exit signals using yhat1/yhat2 crossovers
3. Adaptive trailing stops with kernel regression slopes
4. Take profit optimization using kernel trend estimation
5. Risk management integration with uncertainty quantification

Author: Advanced Kernel Exit Strategy Research Team
Version: 1.0.0
Date: 2025-07-20

References:
- Nadaraya-Watson Kernel Regression Theory
- Rational Quadratic Kernel Applications in Finance
- ATR-Based Dynamic Trailing Stop Strategies
- Monte Carlo Dropout for Uncertainty Estimation
"""

import numpy as np
import pandas as pd
import torch
import torch.nn as nn
from typing import Dict, Any, List, Tuple, Optional, Union
from dataclasses import dataclass
from enum import Enum
import time
import structlog
from collections import deque
from numba import jit, njit
from scipy import stats
from scipy.optimize import minimize
import warnings

from src.indicators.custom.nwrqk import NWRQKCalculator, calculate_nw_regression, rational_quadratic_kernel
from src.execution.agents.risk_management_agent import RiskManagementAgent, ExecutionRiskContext, RiskLevel
from src.core.minimal_dependencies import EventBus, BarData

logger = structlog.get_logger()


class MarketRegime(Enum):
    """Market regime classification for dynamic r-factor adjustment"""
    TRENDING = "trending"
    RANGING = "ranging"
    VOLATILE = "volatile" 
    CALM = "calm"
    TRANSITIONAL = "transitional"


class ExitSignalType(Enum):
    """Types of exit signals generated by the kernel strategy"""
    TRAILING_STOP = "trailing_stop"
    TAKE_PROFIT = "take_profit"
    CROSSOVER_EXIT = "crossover_exit"
    RISK_OVERRIDE = "risk_override"
    REGIME_CHANGE = "regime_change"
    UNCERTAINTY_EXIT = "uncertainty_exit"


@dataclass
class KernelRegressionState:
    """State tracking for kernel regression calculations"""
    yhat1: float
    yhat2: float
    yhat1_slope: float
    yhat2_slope: float
    r_factor: float
    h_parameter: float
    kernel_confidence: float
    regression_variance: float
    calculation_timestamp: float


@dataclass
class ExitParameters:
    """Dynamic exit parameters calculated from kernel regression"""
    trailing_stop_distance: float
    take_profit_distance: float
    stop_loss_price: float
    take_profit_price: float
    confidence_level: float
    signal_strength: float
    exit_urgency: float
    regime_factor: float


@dataclass
class TrailingStopState:
    """State for adaptive trailing stop management"""
    current_stop_price: float
    highest_favorable_price: float
    stop_distance_atr_multiple: float
    acceleration_factor: float
    last_update_timestamp: float
    consecutive_favorable_moves: int


class AdvancedKernelExitStrategy:
    """
    Advanced exit strategy using kernel regression parameters for the Lorentzian 
    Classification trading system.
    
    This strategy implements:
    - Dynamic r-factor adjustments based on market regime detection
    - Kernel regression-based exit signal generation
    - Adaptive trailing stops using regression slopes
    - Multi-level take profit optimization
    - Uncertainty-based risk management
    """
    
    def __init__(self, config: Dict[str, Any], event_bus: Optional[EventBus] = None):
        """
        Initialize the Advanced Kernel Exit Strategy
        
        Args:
            config: Strategy configuration parameters
            event_bus: Event bus for system communication
        """
        self.config = config
        self.event_bus = event_bus
        
        # Core parameters for kernel regression
        self.base_h_parameter = config.get('base_h_parameter', 8.0)
        self.base_r_factor = config.get('base_r_factor', 8.0)
        self.x_0_parameter = config.get('x_0_parameter', 25)
        self.lag_parameter = config.get('lag_parameter', 2)
        
        # Dynamic r-factor adjustment parameters
        self.r_factor_min = config.get('r_factor_min', 2.0)
        self.r_factor_max = config.get('r_factor_max', 20.0)
        self.volatility_lookback = config.get('volatility_lookback', 20)
        self.regime_detection_window = config.get('regime_detection_window', 50)
        
        # Trailing stop parameters
        self.min_atr_multiple = config.get('min_atr_multiple', 1.5)
        self.max_atr_multiple = config.get('max_atr_multiple', 4.0)
        self.acceleration_factor_base = config.get('acceleration_factor_base', 0.02)
        self.acceleration_factor_max = config.get('acceleration_factor_max', 0.2)
        
        # Take profit parameters
        self.min_profit_ratio = config.get('min_profit_ratio', 1.5)
        self.max_profit_ratio = config.get('max_profit_ratio', 5.0)
        self.partial_profit_levels = config.get('partial_profit_levels', [0.25, 0.5, 0.75])
        
        # Risk management integration
        self.uncertainty_threshold = config.get('uncertainty_threshold', 0.3)
        self.max_position_hold_time = config.get('max_position_hold_time', 86400)  # 24 hours
        self.correlation_exit_threshold = config.get('correlation_exit_threshold', 0.8)
        
        # Initialize components
        self.nwrqk_calculator = None  # Will be set externally
        self.risk_manager = None      # Will be set externally
        
        # State tracking
        self.current_positions: Dict[str, Dict] = {}
        self.trailing_stops: Dict[str, TrailingStopState] = {}
        self.kernel_states: Dict[str, KernelRegressionState] = {}
        self.regime_history: deque = deque(maxlen=self.regime_detection_window)
        
        # Performance tracking
        self.exit_signals_generated = 0
        self.successful_exits = 0
        self.risk_override_exits = 0
        self.calculation_times = deque(maxlen=1000)
        
        logger.info("Advanced Kernel Exit Strategy initialized",
                   base_h=self.base_h_parameter,
                   base_r=self.base_r_factor,
                   r_factor_range=(self.r_factor_min, self.r_factor_max))
    
    def detect_market_regime(self, price_history: np.ndarray, volume_history: np.ndarray) -> MarketRegime:
        """
        Detect current market regime using advanced statistical methods
        
        Args:
            price_history: Historical price data
            volume_history: Historical volume data
            
        Returns:
            Current market regime classification
        """
        try:
            if len(price_history) < self.volatility_lookback:
                return MarketRegime.TRANSITIONAL
            
            # Calculate volatility metrics
            returns = np.diff(np.log(price_history))
            volatility = np.std(returns[-self.volatility_lookback:])
            volume_volatility = np.std(volume_history[-self.volatility_lookback:]) / np.mean(volume_history[-self.volatility_lookback:])
            
            # Calculate trend strength using linear regression
            x = np.arange(len(price_history[-self.volatility_lookback:]))
            y = price_history[-self.volatility_lookback:]
            slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
            trend_strength = abs(r_value)
            
            # Calculate range-bound behavior
            price_range = np.max(price_history[-self.volatility_lookback:]) - np.min(price_history[-self.volatility_lookback:])
            normalized_range = price_range / np.mean(price_history[-self.volatility_lookback:])
            
            # Regime classification logic
            if volatility > np.percentile([np.std(np.diff(np.log(price_history[i:i+self.volatility_lookback]))) 
                                         for i in range(0, len(price_history)-self.volatility_lookback, 5)], 75):
                regime = MarketRegime.VOLATILE
            elif volatility < np.percentile([np.std(np.diff(np.log(price_history[i:i+self.volatility_lookback]))) 
                                           for i in range(0, len(price_history)-self.volatility_lookback, 5)], 25):
                regime = MarketRegime.CALM
            elif trend_strength > 0.7 and normalized_range > 0.05:
                regime = MarketRegime.TRENDING
            elif trend_strength < 0.3 and normalized_range < 0.03:
                regime = MarketRegime.RANGING
            else:
                regime = MarketRegime.TRANSITIONAL
            
            # Add to regime history for smoothing
            self.regime_history.append(regime)
            
            # Smooth regime detection over recent history
            if len(self.regime_history) >= 5:
                recent_regimes = list(self.regime_history)[-5:]
                regime_counts = {r: recent_regimes.count(r) for r in set(recent_regimes)}
                regime = max(regime_counts, key=regime_counts.get)
            
            return regime
            
        except Exception as e:
            logger.warning("Error in regime detection", error=str(e))
            return MarketRegime.TRANSITIONAL
    
    def calculate_dynamic_r_factor(self, regime: MarketRegime, volatility: float, trend_strength: float) -> float:
        """
        Calculate dynamic r-factor based on market conditions
        
        Args:
            regime: Current market regime
            volatility: Current volatility measure
            trend_strength: Strength of the current trend
            
        Returns:
            Optimized r-factor value
        """
        try:
            base_r = self.base_r_factor
            
            # Regime-based adjustments
            regime_adjustments = {
                MarketRegime.TRENDING: 0.8,      # Lower r for more responsiveness in trends
                MarketRegime.RANGING: 1.3,       # Higher r for smoother signals in ranges
                MarketRegime.VOLATILE: 0.6,      # Much lower r for quick adaptation
                MarketRegime.CALM: 1.1,          # Slightly higher r in calm markets
                MarketRegime.TRANSITIONAL: 1.0   # No adjustment during transitions
            }
            
            regime_factor = regime_adjustments.get(regime, 1.0)
            
            # Volatility-based adjustment (inverse relationship)
            volatility_factor = 1.0 / (1.0 + volatility * 5.0)  # Higher vol -> lower r
            
            # Trend strength adjustment
            trend_factor = 1.0 + (trend_strength - 0.5) * 0.4  # Strong trends -> slightly higher r
            
            # Calculate final r-factor
            dynamic_r = base_r * regime_factor * volatility_factor * trend_factor
            
            # Constrain within bounds
            dynamic_r = np.clip(dynamic_r, self.r_factor_min, self.r_factor_max)
            
            return float(dynamic_r)
            
        except Exception as e:
            logger.warning("Error calculating dynamic r-factor", error=str(e))
            return self.base_r_factor
    
    def calculate_kernel_regression_with_uncertainty(self, prices: np.ndarray, r_factor: float) -> Tuple[KernelRegressionState, float]:
        """
        Calculate kernel regression with uncertainty estimation using Monte Carlo sampling
        
        Args:
            prices: Price history for regression
            r_factor: Dynamic r-factor parameter
            
        Returns:
            Tuple of (kernel_state, uncertainty_measure)
        """
        start_time = time.perf_counter()
        
        try:
            # Calculate primary regression estimates
            yhat1, yhat2 = calculate_nw_regression(prices, self.base_h_parameter, 
                                                 self.base_h_parameter - self.lag_parameter, 
                                                 r_factor, self.x_0_parameter)
            
            # Get current values
            current_idx = len(prices) - 1
            current_yhat1 = yhat1[current_idx] if not np.isnan(yhat1[current_idx]) else prices[current_idx]
            current_yhat2 = yhat2[current_idx] if not np.isnan(yhat2[current_idx]) else prices[current_idx]
            
            # Calculate slopes for trend analysis
            if current_idx >= 2:
                yhat1_slope = (current_yhat1 - yhat1[current_idx-2]) / 2.0
                yhat2_slope = (current_yhat2 - yhat2[current_idx-2]) / 2.0
            else:
                yhat1_slope = 0.0
                yhat2_slope = 0.0
            
            # Monte Carlo uncertainty estimation
            mc_samples = 100
            mc_yhat1_samples = []
            mc_yhat2_samples = []
            
            for _ in range(mc_samples):
                # Add noise to r_factor for uncertainty sampling
                noise_factor = np.random.normal(1.0, 0.1)
                noisy_r = max(self.r_factor_min, min(self.r_factor_max, r_factor * noise_factor))
                
                # Add price noise
                noisy_prices = prices + np.random.normal(0, np.std(prices) * 0.05, len(prices))
                
                # Calculate regression with noise
                mc_yhat1, mc_yhat2 = calculate_nw_regression(noisy_prices, self.base_h_parameter,
                                                           self.base_h_parameter - self.lag_parameter,
                                                           noisy_r, self.x_0_parameter)
                
                if not np.isnan(mc_yhat1[current_idx]):
                    mc_yhat1_samples.append(mc_yhat1[current_idx])
                if not np.isnan(mc_yhat2[current_idx]):
                    mc_yhat2_samples.append(mc_yhat2[current_idx])
            
            # Calculate uncertainty metrics
            if mc_yhat1_samples and mc_yhat2_samples:
                yhat1_variance = np.var(mc_yhat1_samples)
                yhat2_variance = np.var(mc_yhat2_samples)
                regression_variance = (yhat1_variance + yhat2_variance) / 2.0
                
                # Confidence based on variance
                max_expected_variance = (np.std(prices) * 0.1) ** 2
                kernel_confidence = 1.0 - min(1.0, regression_variance / max_expected_variance)
            else:
                regression_variance = 0.0
                kernel_confidence = 0.5
            
            # Create kernel state
            kernel_state = KernelRegressionState(
                yhat1=current_yhat1,
                yhat2=current_yhat2,
                yhat1_slope=yhat1_slope,
                yhat2_slope=yhat2_slope,
                r_factor=r_factor,
                h_parameter=self.base_h_parameter,
                kernel_confidence=kernel_confidence,
                regression_variance=regression_variance,
                calculation_timestamp=time.time()
            )
            
            # Calculate overall uncertainty
            slope_uncertainty = abs(yhat1_slope - yhat2_slope) / max(abs(yhat1_slope) + abs(yhat2_slope), 0.001)
            uncertainty_measure = (1.0 - kernel_confidence) * 0.7 + slope_uncertainty * 0.3
            
            # Performance tracking
            calculation_time = time.perf_counter() - start_time
            self.calculation_times.append(calculation_time)
            
            return kernel_state, uncertainty_measure
            
        except Exception as e:
            logger.error("Error in kernel regression calculation", error=str(e))
            # Return safe defaults
            kernel_state = KernelRegressionState(
                yhat1=prices[-1], yhat2=prices[-1], yhat1_slope=0.0, yhat2_slope=0.0,
                r_factor=r_factor, h_parameter=self.base_h_parameter,
                kernel_confidence=0.1, regression_variance=1.0,
                calculation_timestamp=time.time()
            )
            return kernel_state, 1.0
    
    def detect_crossover_signals(self, kernel_state: KernelRegressionState, previous_state: Optional[KernelRegressionState]) -> List[Dict[str, Any]]:
        """
        Detect exit signals based on yhat1/yhat2 crossovers and rate of change analysis
        
        Args:
            kernel_state: Current kernel regression state
            previous_state: Previous kernel regression state
            
        Returns:
            List of detected exit signals
        """
        signals = []
        
        try:
            if previous_state is None:
                return signals
            
            # Crossover detection
            yhat1_current = kernel_state.yhat1
            yhat2_current = kernel_state.yhat2
            yhat1_previous = previous_state.yhat1
            yhat2_previous = previous_state.yhat2
            
            # Bullish crossover (yhat2 crosses above yhat1) - potential long exit signal
            if (yhat2_previous <= yhat1_previous and yhat2_current > yhat1_current):
                crossover_strength = abs(yhat2_current - yhat1_current) / max(abs(yhat1_current), 0.001)
                signals.append({
                    'type': ExitSignalType.CROSSOVER_EXIT,
                    'direction': 'bullish_crossover',
                    'strength': crossover_strength,
                    'confidence': kernel_state.kernel_confidence,
                    'recommended_action': 'exit_short',
                    'urgency': min(1.0, crossover_strength * 2.0)
                })
            
            # Bearish crossover (yhat2 crosses below yhat1) - potential short exit signal
            elif (yhat2_previous >= yhat1_previous and yhat2_current < yhat1_current):
                crossover_strength = abs(yhat1_current - yhat2_current) / max(abs(yhat1_current), 0.001)
                signals.append({
                    'type': ExitSignalType.CROSSOVER_EXIT,
                    'direction': 'bearish_crossover',
                    'strength': crossover_strength,
                    'confidence': kernel_state.kernel_confidence,
                    'recommended_action': 'exit_long',
                    'urgency': min(1.0, crossover_strength * 2.0)
                })
            
            # Rate of change analysis
            yhat1_acceleration = kernel_state.yhat1_slope - previous_state.yhat1_slope
            yhat2_acceleration = kernel_state.yhat2_slope - previous_state.yhat2_slope
            
            # Deceleration signals (trend weakening)
            if abs(yhat1_acceleration) > 0.001:  # Threshold for meaningful acceleration change
                deceleration_strength = abs(yhat1_acceleration) / max(abs(previous_state.yhat1_slope), 0.001)
                
                if yhat1_acceleration < 0 and previous_state.yhat1_slope > 0:  # Uptrend decelerating
                    signals.append({
                        'type': ExitSignalType.CROSSOVER_EXIT,
                        'direction': 'uptrend_deceleration',
                        'strength': deceleration_strength,
                        'confidence': kernel_state.kernel_confidence * 0.8,
                        'recommended_action': 'reduce_long',
                        'urgency': min(0.7, deceleration_strength)
                    })
                
                elif yhat1_acceleration > 0 and previous_state.yhat1_slope < 0:  # Downtrend decelerating
                    signals.append({
                        'type': ExitSignalType.CROSSOVER_EXIT,
                        'direction': 'downtrend_deceleration',
                        'strength': deceleration_strength,
                        'confidence': kernel_state.kernel_confidence * 0.8,
                        'recommended_action': 'reduce_short',
                        'urgency': min(0.7, deceleration_strength)
                    })
            
            return signals
            
        except Exception as e:
            logger.warning("Error detecting crossover signals", error=str(e))
            return signals
    
    def calculate_adaptive_trailing_stop(self, 
                                       position_info: Dict[str, Any], 
                                       current_price: float,
                                       kernel_state: KernelRegressionState,
                                       atr_value: float) -> TrailingStopState:
        """
        Calculate adaptive trailing stop using kernel regression slopes and ATR
        
        Args:
            position_info: Current position information
            current_price: Current market price
            kernel_state: Current kernel regression state
            atr_value: Current ATR value
            
        Returns:
            Updated trailing stop state
        """
        try:
            symbol = position_info['symbol']
            position_size = position_info['size']
            entry_price = position_info['entry_price']
            is_long = position_size > 0
            
            # Get existing trailing stop state or create new one
            if symbol in self.trailing_stops:
                stop_state = self.trailing_stops[symbol]
            else:
                # Initialize new trailing stop
                initial_distance = atr_value * self.min_atr_multiple
                if is_long:
                    initial_stop = current_price - initial_distance
                    highest_favorable = current_price
                else:
                    initial_stop = current_price + initial_distance
                    highest_favorable = current_price
                
                stop_state = TrailingStopState(
                    current_stop_price=initial_stop,
                    highest_favorable_price=highest_favorable,
                    stop_distance_atr_multiple=self.min_atr_multiple,
                    acceleration_factor=self.acceleration_factor_base,
                    last_update_timestamp=time.time(),
                    consecutive_favorable_moves=0
                )
            
            # Calculate slope-based adjustment factor
            slope_factor = 1.0
            if abs(kernel_state.yhat1_slope) > 0.001:
                if is_long and kernel_state.yhat1_slope > 0:
                    # Positive slope in long position - tighten stop
                    slope_factor = 1.0 - min(0.3, abs(kernel_state.yhat1_slope) / current_price)
                elif not is_long and kernel_state.yhat1_slope < 0:
                    # Negative slope in short position - tighten stop
                    slope_factor = 1.0 - min(0.3, abs(kernel_state.yhat1_slope) / current_price)
                else:
                    # Slope against position - loosen stop
                    slope_factor = 1.0 + min(0.2, abs(kernel_state.yhat1_slope) / current_price)
            
            # Update highest favorable price and check for acceleration
            if is_long:
                if current_price > stop_state.highest_favorable_price:
                    stop_state.highest_favorable_price = current_price
                    stop_state.consecutive_favorable_moves += 1
                else:
                    stop_state.consecutive_favorable_moves = 0
            else:
                if current_price < stop_state.highest_favorable_price:
                    stop_state.highest_favorable_price = current_price
                    stop_state.consecutive_favorable_moves += 1
                else:
                    stop_state.consecutive_favorable_moves = 0
            
            # Calculate acceleration factor based on consecutive favorable moves
            if stop_state.consecutive_favorable_moves > 3:
                acceleration_increment = self.acceleration_factor_base * (stop_state.consecutive_favorable_moves - 3)
                stop_state.acceleration_factor = min(
                    self.acceleration_factor_max,
                    stop_state.acceleration_factor + acceleration_increment
                )
            
            # Calculate dynamic ATR multiple
            base_multiple = self.min_atr_multiple
            kernel_confidence_factor = 1.0 + (1.0 - kernel_state.kernel_confidence) * 0.5
            acceleration_multiplier = 1.0 - stop_state.acceleration_factor
            
            dynamic_atr_multiple = base_multiple * slope_factor * kernel_confidence_factor * acceleration_multiplier
            dynamic_atr_multiple = np.clip(dynamic_atr_multiple, self.min_atr_multiple, self.max_atr_multiple)
            
            # Calculate new stop price
            stop_distance = atr_value * dynamic_atr_multiple
            
            if is_long:
                new_stop_price = stop_state.highest_favorable_price - stop_distance
                # Trailing stop can only move up for long positions
                stop_state.current_stop_price = max(stop_state.current_stop_price, new_stop_price)
            else:
                new_stop_price = stop_state.highest_favorable_price + stop_distance
                # Trailing stop can only move down for short positions
                stop_state.current_stop_price = min(stop_state.current_stop_price, new_stop_price)
            
            stop_state.stop_distance_atr_multiple = dynamic_atr_multiple
            stop_state.last_update_timestamp = time.time()
            
            # Store updated state
            self.trailing_stops[symbol] = stop_state
            
            return stop_state
            
        except Exception as e:
            logger.error("Error calculating adaptive trailing stop", error=str(e))
            # Return safe default
            return TrailingStopState(
                current_stop_price=entry_price * 0.95 if is_long else entry_price * 1.05,
                highest_favorable_price=current_price,
                stop_distance_atr_multiple=self.min_atr_multiple,
                acceleration_factor=self.acceleration_factor_base,
                last_update_timestamp=time.time(),
                consecutive_favorable_moves=0
            )
    
    def calculate_take_profit_levels(self, 
                                   position_info: Dict[str, Any],
                                   kernel_state: KernelRegressionState,
                                   atr_value: float) -> List[Dict[str, Any]]:
        """
        Calculate multiple take profit levels based on kernel trend estimation
        
        Args:
            position_info: Current position information
            kernel_state: Current kernel regression state
            atr_value: Current ATR value
            
        Returns:
            List of take profit level specifications
        """
        try:
            position_size = position_info['size']
            entry_price = position_info['entry_price']
            current_price = position_info.get('current_price', entry_price)
            is_long = position_size > 0
            
            take_profit_levels = []
            
            # Base profit distance using kernel trend strength
            trend_strength = abs(kernel_state.yhat1_slope) / max(abs(current_price), 1.0)
            base_profit_distance = atr_value * self.min_profit_ratio
            
            # Adjust based on trend strength and kernel confidence
            trend_factor = 1.0 + trend_strength * 2.0
            confidence_factor = 0.5 + kernel_state.kernel_confidence * 0.5
            
            adjusted_profit_distance = base_profit_distance * trend_factor * confidence_factor
            
            # Calculate multiple take profit levels
            for i, partial_level in enumerate(self.partial_profit_levels):
                level_multiplier = 1.0 + i * 0.8  # Increasing distance for each level
                profit_distance = adjusted_profit_distance * level_multiplier
                
                if is_long:
                    target_price = entry_price + profit_distance
                else:
                    target_price = entry_price - profit_distance
                
                # Calculate position percentage to close at this level
                if i == len(self.partial_profit_levels) - 1:
                    # Close remaining position at final level
                    position_percentage = 1.0 - sum(self.partial_profit_levels[:-1])
                else:
                    position_percentage = partial_level
                
                # Estimate probability of reaching this level based on kernel projection
                distance_ratio = abs(target_price - current_price) / abs(entry_price - current_price)
                reach_probability = max(0.1, kernel_state.kernel_confidence / distance_ratio)
                
                take_profit_levels.append({
                    'level': i + 1,
                    'target_price': target_price,
                    'position_percentage': position_percentage,
                    'profit_distance_atr': profit_distance / atr_value,
                    'reach_probability': reach_probability,
                    'kernel_confidence': kernel_state.kernel_confidence,
                    'trend_strength': trend_strength,
                    'expected_return': (target_price - entry_price) / entry_price if is_long else (entry_price - target_price) / entry_price
                })
            
            return take_profit_levels
            
        except Exception as e:
            logger.error("Error calculating take profit levels", error=str(e))
            return []
    
    def assess_position_risk(self, 
                           position_info: Dict[str, Any],
                           kernel_state: KernelRegressionState,
                           uncertainty_measure: float) -> Dict[str, Any]:
        """
        Assess position risk using kernel regression uncertainty and market conditions
        
        Args:
            position_info: Current position information
            kernel_state: Current kernel regression state
            uncertainty_measure: Uncertainty measure from kernel regression
            
        Returns:
            Risk assessment results
        """
        try:
            position_size = position_info['size']
            entry_price = position_info['entry_price']
            current_price = position_info.get('current_price', entry_price)
            entry_time = position_info.get('entry_time', time.time())
            
            risk_factors = {}
            risk_score = 0.0
            risk_recommendations = []
            
            # 1. Uncertainty-based risk
            if uncertainty_measure > self.uncertainty_threshold:
                risk_factors['high_uncertainty'] = uncertainty_measure
                risk_score += uncertainty_measure * 0.3
                risk_recommendations.append('Consider reducing position due to high uncertainty')
            
            # 2. Kernel confidence risk
            if kernel_state.kernel_confidence < 0.5:
                risk_factors['low_kernel_confidence'] = kernel_state.kernel_confidence
                risk_score += (0.5 - kernel_state.kernel_confidence) * 0.4
                risk_recommendations.append('Low kernel confidence suggests unreliable signals')
            
            # 3. Time-based risk (position aging)
            position_age = time.time() - entry_time
            if position_age > self.max_position_hold_time:
                age_risk = min(1.0, (position_age - self.max_position_hold_time) / self.max_position_hold_time)
                risk_factors['position_age_risk'] = age_risk
                risk_score += age_risk * 0.2
                risk_recommendations.append('Position held too long, consider exit')
            
            # 4. Trend reversal risk based on slope changes
            slope_reversal_risk = 0.0
            if abs(kernel_state.yhat1_slope) > 0.001:
                # Check if slope is against the position
                is_long = position_size > 0
                if (is_long and kernel_state.yhat1_slope < -0.001) or (not is_long and kernel_state.yhat1_slope > 0.001):
                    slope_reversal_risk = min(1.0, abs(kernel_state.yhat1_slope) / (current_price * 0.01))
                    risk_factors['trend_reversal_risk'] = slope_reversal_risk
                    risk_score += slope_reversal_risk * 0.3
                    risk_recommendations.append('Kernel slope indicates potential trend reversal')
            
            # 5. Volatility risk based on regression variance
            if kernel_state.regression_variance > 0:
                normalized_variance = kernel_state.regression_variance / (current_price * 0.01) ** 2
                if normalized_variance > 1.0:
                    volatility_risk = min(1.0, normalized_variance - 1.0)
                    risk_factors['high_volatility_risk'] = volatility_risk
                    risk_score += volatility_risk * 0.25
                    risk_recommendations.append('High regression variance indicates increased volatility')
            
            # Overall risk level classification
            if risk_score > 0.8:
                risk_level = RiskLevel.CRITICAL
                recommended_action = 'immediate_exit'
            elif risk_score > 0.6:
                risk_level = RiskLevel.HIGH
                recommended_action = 'reduce_position'
            elif risk_score > 0.4:
                risk_level = RiskLevel.MODERATE
                recommended_action = 'monitor_closely'
            elif risk_score > 0.2:
                risk_level = RiskLevel.LOW
                recommended_action = 'maintain_position'
            else:
                risk_level = RiskLevel.LOW
                recommended_action = 'maintain_position'
            
            return {
                'risk_score': risk_score,
                'risk_level': risk_level,
                'risk_factors': risk_factors,
                'recommendations': risk_recommendations,
                'recommended_action': recommended_action,
                'uncertainty_measure': uncertainty_measure,
                'kernel_confidence': kernel_state.kernel_confidence,
                'assessment_timestamp': time.time()
            }
            
        except Exception as e:
            logger.error("Error in position risk assessment", error=str(e))
            return {
                'risk_score': 1.0,
                'risk_level': RiskLevel.CRITICAL,
                'risk_factors': {'assessment_error': str(e)},
                'recommendations': ['Error in risk assessment - consider exit'],
                'recommended_action': 'immediate_exit',
                'uncertainty_measure': 1.0,
                'kernel_confidence': 0.0,
                'assessment_timestamp': time.time()
            }
    
    def generate_exit_decision(self,
                             position_info: Dict[str, Any],
                             current_price: float,
                             price_history: np.ndarray,
                             volume_history: np.ndarray,
                             atr_value: float) -> Dict[str, Any]:
        """
        Generate comprehensive exit decision using all kernel regression parameters
        
        Args:
            position_info: Current position information
            current_price: Current market price
            price_history: Historical price data
            volume_history: Historical volume data
            atr_value: Current ATR value
            
        Returns:
            Comprehensive exit decision with all parameters
        """
        start_time = time.perf_counter()
        
        try:
            symbol = position_info['symbol']
            
            # 1. Detect market regime and calculate dynamic r-factor
            regime = self.detect_market_regime(price_history, volume_history)
            returns = np.diff(np.log(price_history))
            volatility = np.std(returns[-self.volatility_lookback:]) if len(returns) >= self.volatility_lookback else 0.1
            
            # Calculate trend strength
            x = np.arange(len(price_history[-20:]))
            y = price_history[-20:]
            slope, _, r_value, _, _ = stats.linregress(x, y) if len(y) >= 2 else (0, 0, 0, 0, 0)
            trend_strength = abs(r_value)
            
            dynamic_r_factor = self.calculate_dynamic_r_factor(regime, volatility, trend_strength)
            
            # 2. Calculate kernel regression with uncertainty
            kernel_state, uncertainty_measure = self.calculate_kernel_regression_with_uncertainty(
                price_history, dynamic_r_factor
            )
            
            # Store kernel state
            previous_state = self.kernel_states.get(symbol)
            self.kernel_states[symbol] = kernel_state
            
            # 3. Detect crossover signals
            crossover_signals = self.detect_crossover_signals(kernel_state, previous_state)
            
            # 4. Calculate adaptive trailing stop
            trailing_stop_state = self.calculate_adaptive_trailing_stop(
                position_info, current_price, kernel_state, atr_value
            )
            
            # 5. Calculate take profit levels
            take_profit_levels = self.calculate_take_profit_levels(
                position_info, kernel_state, atr_value
            )
            
            # 6. Assess position risk
            risk_assessment = self.assess_position_risk(
                position_info, kernel_state, uncertainty_measure
            )
            
            # 7. Determine primary exit signals
            exit_signals = []
            
            # Check trailing stop trigger
            is_long = position_info['size'] > 0
            if is_long and current_price <= trailing_stop_state.current_stop_price:
                exit_signals.append({
                    'type': ExitSignalType.TRAILING_STOP,
                    'price': trailing_stop_state.current_stop_price,
                    'urgency': 1.0,
                    'reason': 'trailing_stop_triggered'
                })
            elif not is_long and current_price >= trailing_stop_state.current_stop_price:
                exit_signals.append({
                    'type': ExitSignalType.TRAILING_STOP,
                    'price': trailing_stop_state.current_stop_price,
                    'urgency': 1.0,
                    'reason': 'trailing_stop_triggered'
                })
            
            # Check take profit triggers
            for tp_level in take_profit_levels:
                if is_long and current_price >= tp_level['target_price']:
                    exit_signals.append({
                        'type': ExitSignalType.TAKE_PROFIT,
                        'price': tp_level['target_price'],
                        'urgency': 0.8,
                        'position_percentage': tp_level['position_percentage'],
                        'level': tp_level['level'],
                        'reason': f'take_profit_level_{tp_level["level"]}'
                    })
                elif not is_long and current_price <= tp_level['target_price']:
                    exit_signals.append({
                        'type': ExitSignalType.TAKE_PROFIT,
                        'price': tp_level['target_price'],
                        'urgency': 0.8,
                        'position_percentage': tp_level['position_percentage'],
                        'level': tp_level['level'],
                        'reason': f'take_profit_level_{tp_level["level"]}'
                    })
            
            # Add crossover signals
            exit_signals.extend(crossover_signals)
            
            # Check risk override conditions
            if risk_assessment['risk_level'] == RiskLevel.CRITICAL:
                exit_signals.append({
                    'type': ExitSignalType.RISK_OVERRIDE,
                    'price': current_price,
                    'urgency': 1.0,
                    'reason': 'critical_risk_detected',
                    'risk_factors': risk_assessment['risk_factors']
                })
            
            # Check uncertainty-based exit
            if uncertainty_measure > self.uncertainty_threshold:
                exit_signals.append({
                    'type': ExitSignalType.UNCERTAINTY_EXIT,
                    'price': current_price,
                    'urgency': min(1.0, uncertainty_measure),
                    'reason': 'high_uncertainty',
                    'uncertainty_level': uncertainty_measure
                })
            
            # 8. Calculate exit parameters
            exit_params = ExitParameters(
                trailing_stop_distance=abs(current_price - trailing_stop_state.current_stop_price),
                take_profit_distance=take_profit_levels[0]['profit_distance_atr'] * atr_value if take_profit_levels else 0,
                stop_loss_price=trailing_stop_state.current_stop_price,
                take_profit_price=take_profit_levels[0]['target_price'] if take_profit_levels else current_price,
                confidence_level=kernel_state.kernel_confidence,
                signal_strength=max([signal.get('strength', 0) for signal in crossover_signals], default=0),
                exit_urgency=max([signal['urgency'] for signal in exit_signals], default=0),
                regime_factor=dynamic_r_factor / self.base_r_factor
            )
            
            # 9. Performance tracking
            calculation_time = time.perf_counter() - start_time
            self.calculation_times.append(calculation_time)
            self.exit_signals_generated += len(exit_signals)
            
            if exit_signals:
                logger.info("Exit signals generated",
                           symbol=symbol,
                           num_signals=len(exit_signals),
                           max_urgency=max([s['urgency'] for s in exit_signals]),
                           regime=regime.value,
                           r_factor=dynamic_r_factor,
                           uncertainty=uncertainty_measure)
            
            return {
                'symbol': symbol,
                'timestamp': time.time(),
                'current_price': current_price,
                'exit_signals': exit_signals,
                'exit_parameters': exit_params,
                'kernel_state': kernel_state,
                'trailing_stop_state': trailing_stop_state,
                'take_profit_levels': take_profit_levels,
                'risk_assessment': risk_assessment,
                'market_regime': regime,
                'dynamic_r_factor': dynamic_r_factor,
                'uncertainty_measure': uncertainty_measure,
                'calculation_time_ms': calculation_time * 1000,
                'performance_stats': self.get_performance_stats()
            }
            
        except Exception as e:
            logger.error("Error generating exit decision", error=str(e), symbol=position_info.get('symbol'))
            return {
                'symbol': position_info.get('symbol'),
                'timestamp': time.time(),
                'current_price': current_price,
                'exit_signals': [{
                    'type': ExitSignalType.RISK_OVERRIDE,
                    'price': current_price,
                    'urgency': 1.0,
                    'reason': 'calculation_error',
                    'error': str(e)
                }],
                'error': str(e)
            }
    
    def get_performance_stats(self) -> Dict[str, Any]:
        """Get strategy performance statistics"""
        if not self.calculation_times:
            return {'no_data': True}
        
        recent_times = list(self.calculation_times)
        
        return {
            'exit_signals_generated': self.exit_signals_generated,
            'successful_exits': self.successful_exits,
            'risk_override_exits': self.risk_override_exits,
            'avg_calculation_time_ms': np.mean(recent_times) * 1000,
            'max_calculation_time_ms': np.max(recent_times) * 1000,
            'p95_calculation_time_ms': np.percentile(recent_times, 95) * 1000,
            'active_positions': len(self.current_positions),
            'active_trailing_stops': len(self.trailing_stops),
            'regime_history_length': len(self.regime_history)
        }
    
    def reset_strategy_state(self):
        """Reset all strategy state for new trading session"""
        self.current_positions.clear()
        self.trailing_stops.clear()
        self.kernel_states.clear()
        self.regime_history.clear()
        self.exit_signals_generated = 0
        self.successful_exits = 0
        self.risk_override_exits = 0
        self.calculation_times.clear()
        
        logger.info("Advanced Kernel Exit Strategy state reset")


@njit
def fast_kernel_weight_calculation(x_t: float, x_i: float, h: float, r: float) -> float:
    """
    Fast numba-compiled kernel weight calculation
    
    Args:
        x_t: Current observation
        x_i: Historical observation
        h: Bandwidth parameter
        r: Alpha parameter (r-factor)
        
    Returns:
        Kernel weight
    """
    distance_squared = (x_t - x_i) ** 2
    epsilon = 1e-10
    return (1 + (distance_squared + epsilon) / (2 * r * h**2)) ** (-r)


def create_kernel_exit_strategy(config: Dict[str, Any], event_bus: Optional[EventBus] = None) -> AdvancedKernelExitStrategy:
    """
    Factory function to create and initialize an Advanced Kernel Exit Strategy
    
    Args:
        config: Strategy configuration
        event_bus: Event bus for system communication
        
    Returns:
        Initialized strategy instance
    """
    return AdvancedKernelExitStrategy(config, event_bus)


def run_strategy_backtest(strategy: AdvancedKernelExitStrategy,
                         price_data: pd.DataFrame,
                         position_data: pd.DataFrame,
                         config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Run a comprehensive backtest of the kernel exit strategy
    
    Args:
        strategy: Initialized strategy instance
        price_data: Historical price data with OHLCV
        position_data: Historical position data
        config: Backtest configuration
        
    Returns:
        Comprehensive backtest results
    """
    logger.info("Starting kernel exit strategy backtest",
               price_data_rows=len(price_data),
               position_data_rows=len(position_data))
    
    backtest_results = {
        'total_exit_decisions': 0,
        'successful_exits': 0,
        'risk_override_exits': 0,
        'trailing_stop_exits': 0,
        'take_profit_exits': 0,
        'crossover_exits': 0,
        'uncertainty_exits': 0,
        'average_holding_time': 0,
        'total_return': 0,
        'sharpe_ratio': 0,
        'max_drawdown': 0,
        'win_rate': 0,
        'performance_by_regime': {},
        'exit_signal_analysis': {},
        'calculation_performance': {}
    }
    
    try:
        # Reset strategy state
        strategy.reset_strategy_state()
        
        # Process each position through the strategy
        for _, position in position_data.iterrows():
            symbol = position['symbol']
            entry_time = position['entry_time']
            exit_time = position.get('exit_time', entry_time + 3600)  # Default 1 hour
            
            # Get price history for this position period
            position_prices = price_data[
                (price_data['timestamp'] >= entry_time - 3600) &  # 1 hour before entry
                (price_data['timestamp'] <= exit_time)
            ]
            
            if len(position_prices) < 50:  # Need sufficient history
                continue
            
            # Simulate real-time exit decisions
            for i in range(25, len(position_prices)):  # Start after warmup period
                current_bar = position_prices.iloc[i]
                price_history = position_prices.iloc[:i]['close'].values
                volume_history = position_prices.iloc[:i]['volume'].values
                
                # Calculate ATR (simplified)
                high_low = position_prices.iloc[max(0, i-14):i]['high'].values - position_prices.iloc[max(0, i-14):i]['low'].values
                atr_value = np.mean(high_low) if len(high_low) > 0 else 1.0
                
                # Generate exit decision
                position_info = {
                    'symbol': symbol,
                    'size': position['size'],
                    'entry_price': position['entry_price'],
                    'entry_time': entry_time,
                    'current_price': current_bar['close']
                }
                
                exit_decision = strategy.generate_exit_decision(
                    position_info=position_info,
                    current_price=current_bar['close'],
                    price_history=price_history,
                    volume_history=volume_history,
                    atr_value=atr_value
                )
                
                backtest_results['total_exit_decisions'] += 1
                
                # Analyze exit signals
                for signal in exit_decision.get('exit_signals', []):
                    signal_type = signal['type'].value
                    if signal_type not in backtest_results['exit_signal_analysis']:
                        backtest_results['exit_signal_analysis'][signal_type] = 0
                    backtest_results['exit_signal_analysis'][signal_type] += 1
                    
                    # Count by type
                    if signal['type'] == ExitSignalType.TRAILING_STOP:
                        backtest_results['trailing_stop_exits'] += 1
                    elif signal['type'] == ExitSignalType.TAKE_PROFIT:
                        backtest_results['take_profit_exits'] += 1
                    elif signal['type'] == ExitSignalType.CROSSOVER_EXIT:
                        backtest_results['crossover_exits'] += 1
                    elif signal['type'] == ExitSignalType.RISK_OVERRIDE:
                        backtest_results['risk_override_exits'] += 1
                    elif signal['type'] == ExitSignalType.UNCERTAINTY_EXIT:
                        backtest_results['uncertainty_exits'] += 1
                
                # Track regime performance
                regime = exit_decision.get('market_regime', MarketRegime.TRANSITIONAL).value
                if regime not in backtest_results['performance_by_regime']:
                    backtest_results['performance_by_regime'][regime] = {
                        'signals': 0, 'avg_confidence': 0, 'avg_uncertainty': 0
                    }
                
                regime_stats = backtest_results['performance_by_regime'][regime]
                regime_stats['signals'] += 1
                regime_stats['avg_confidence'] += exit_decision.get('kernel_state', KernelRegressionState()).kernel_confidence
                regime_stats['avg_uncertainty'] += exit_decision.get('uncertainty_measure', 0)
        
        # Calculate final statistics
        strategy_stats = strategy.get_performance_stats()
        backtest_results['calculation_performance'] = strategy_stats
        
        # Average regime statistics
        for regime, stats in backtest_results['performance_by_regime'].items():
            if stats['signals'] > 0:
                stats['avg_confidence'] /= stats['signals']
                stats['avg_uncertainty'] /= stats['signals']
        
        logger.info("Kernel exit strategy backtest completed", 
                   total_decisions=backtest_results['total_exit_decisions'],
                   regimes_analyzed=len(backtest_results['performance_by_regime']))
        
        return backtest_results
        
    except Exception as e:
        logger.error("Error in strategy backtest", error=str(e))
        backtest_results['error'] = str(e)
        return backtest_results


# Configuration template for the strategy
DEFAULT_STRATEGY_CONFIG = {
    # Kernel parameters
    'base_h_parameter': 8.0,
    'base_r_factor': 8.0,
    'x_0_parameter': 25,
    'lag_parameter': 2,
    
    # Dynamic r-factor adjustment
    'r_factor_min': 2.0,
    'r_factor_max': 20.0,
    'volatility_lookback': 20,
    'regime_detection_window': 50,
    
    # Trailing stop parameters
    'min_atr_multiple': 1.5,
    'max_atr_multiple': 4.0,
    'acceleration_factor_base': 0.02,
    'acceleration_factor_max': 0.2,
    
    # Take profit parameters
    'min_profit_ratio': 1.5,
    'max_profit_ratio': 5.0,
    'partial_profit_levels': [0.25, 0.5, 0.75],
    
    # Risk management
    'uncertainty_threshold': 0.3,
    'max_position_hold_time': 86400,  # 24 hours
    'correlation_exit_threshold': 0.8,
    
    # Performance optimization
    'enable_mc_uncertainty': True,
    'mc_samples': 100,
    'calculation_timeout_ms': 100,
    'enable_jit_compilation': True
}


if __name__ == "__main__":
    # Example usage and testing
    import json
    
    # Initialize strategy with default config
    strategy = create_kernel_exit_strategy(DEFAULT_STRATEGY_CONFIG)
    
    # Generate sample data for testing
    np.random.seed(42)
    n_bars = 1000
    
    price_data = pd.DataFrame({
        'timestamp': np.arange(n_bars),
        'open': 100 + np.cumsum(np.random.normal(0, 0.5, n_bars)),
        'high': 100 + np.cumsum(np.random.normal(0, 0.5, n_bars)) + np.random.uniform(0, 1, n_bars),
        'low': 100 + np.cumsum(np.random.normal(0, 0.5, n_bars)) - np.random.uniform(0, 1, n_bars),
        'close': 100 + np.cumsum(np.random.normal(0, 0.5, n_bars)),
        'volume': np.random.uniform(1000, 10000, n_bars)
    })
    
    position_data = pd.DataFrame({
        'symbol': ['TEST'] * 10,
        'size': [100] * 10,
        'entry_price': price_data['close'].iloc[::100][:10].values,
        'entry_time': price_data['timestamp'].iloc[::100][:10].values,
        'exit_time': price_data['timestamp'].iloc[::100][:10].values + 100
    })
    
    # Run backtest
    backtest_config = {'enable_detailed_logging': True}
    results = run_strategy_backtest(strategy, price_data, position_data, backtest_config)
    
    print("Backtest Results:")
    print(json.dumps({k: v for k, v in results.items() if not isinstance(v, Exception)}, indent=2, default=str))