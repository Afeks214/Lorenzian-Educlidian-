"""
Comprehensive Integration Test for Parallel MARL System

Tests the complete data flow:
Market Data → MMD Processing → 30m/5m Matrices → 8 Parallel Agents → Decisions

Validates 300% trustworthy data delivery and agent interconnections.
"""

import pytest
import asyncio
import numpy as np
from unittest.mock import Mock, patch, AsyncMock
from datetime import datetime, timedelta
import time

from src.core.minimal_dependencies import Event, EventType
from src.core.event_bus import EventBus
from src.matrix.assembler_30m import MatrixAssembler30m
from src.matrix.assembler_5m import MatrixAssembler5m
from src.matrix.mmd_processor import MMDProcessor
from src.agents.parallel_marl_system import ParallelMARLSystem, MatrixDeliveryValidator


class TestParallelMARLIntegration:
    """Integration tests for the complete parallel MARL system."""
    
    @pytest.fixture
    async def event_bus(self):
        """Create event bus."""
        return EventBus()
    
    @pytest.fixture
    def sample_market_data(self):
        """Generate sample market data."""
        return {
            'timestamp': datetime.now(),
            'symbol': 'EURUSD',
            'timeframe': '30m',
            'open': 1.0500,
            'high': 1.0520,
            'low': 1.0495,
            'close': 1.0515,
            'volume': 1000.0,
            'spread': 0.0001,
            'bid_volume': 500.0,
            'ask_volume': 500.0,
            'current_price': 1.0515,
            'current_volume': 1000.0
        }
    
    @pytest.fixture
    def sample_indicators(self):
        """Generate sample technical indicators."""\n        return {\n            'mlmi_value': 55.5,\n            'mlmi_signal': 1,\n            'nwrqk_value': 1.0510,\n            'nwrqk_slope': 0.15,\n            'lvn_distance_points': 5.25,\n            'lvn_nearest_strength': 85.5,\n            'fvg_bullish_active': 1,\n            'fvg_bearish_active': 0,\n            'fvg_nearest_level': 1.0518,\n            'fvg_age': 3,\n            'fvg_mitigation_signal': 0,\n            'price_momentum_5': 0.02,\n            'volume_ratio': 1.2,\n            'current_price': 1.0515\n        }\n    \n    @pytest.fixture\n    def assembler_30m_config(self):\n        \"\"\"30m assembler configuration.\"\"\"\n        return {\n            'name': 'MatrixAssembler30m_Test',\n            'window_size': 10,  # Smaller for testing\n            'features': [\n                'mlmi_value', 'mlmi_signal', 'nwrqk_value', 'nwrqk_slope',\n                'lvn_distance_points', 'lvn_nearest_strength',\n                'mmd_pc1', 'mmd_pc2', 'mmd_pc3'\n            ],\n            'kernel': Mock(),\n            'mmd_config': {\n                'window_size': 20,\n                'method': 'pca',\n                'update_frequency': 5\n            }\n        }\n    \n    @pytest.fixture\n    def assembler_5m_config(self):\n        \"\"\"5m assembler configuration.\"\"\"\n        return {\n            'name': 'MatrixAssembler5m_Test',\n            'window_size': 10,  # Smaller for testing\n            'features': [\n                'fvg_bullish_active', 'fvg_bearish_active', 'fvg_nearest_level',\n                'fvg_age', 'fvg_mitigation_signal', 'price_momentum_5', 'volume_ratio'\n            ],\n            'kernel': Mock()\n        }\n    \n    @pytest.mark.asyncio\n    async def test_mmd_processor_integration(self, sample_market_data):\n        \"\"\"Test MMD processor with PCA/t-SNE integration.\"\"\"\n        # Test PCA method\n        mmd_processor = MMDProcessor(window_size=20, method='pca')\n        \n        # Process multiple samples to train PCA\n        for i in range(25):\n            # Vary the market data slightly\n            market_data = sample_market_data.copy()\n            market_data['close'] += i * 0.0001\n            market_data['volume'] += i * 10\n            \n            mmd_components = mmd_processor.process_30m_mmd(market_data)\n            \n            # Verify output shape\n            assert mmd_components.shape == (3,), f\"Expected 3 components, got {mmd_components.shape}\"\n            \n            # Verify values are finite\n            assert np.all(np.isfinite(mmd_components)), \"MMD components contain non-finite values\"\n        \n        # Check if PCA is fitted after sufficient samples\n        assert mmd_processor.is_fitted, \"MMD processor should be fitted after 25 samples\"\n        \n        # Get statistics\n        stats = mmd_processor.get_statistics()\n        assert stats['method'] == 'pca'\n        assert stats['n_updates'] == 25\n        assert 'explained_variance' in stats\n        \n        # Test component interpretation\n        interpretation = mmd_processor.get_component_interpretation()\n        assert len(interpretation) == 3\n        assert 'PC1' in interpretation\n        assert 'PC2' in interpretation\n        assert 'PC3' in interpretation\n    \n    @pytest.mark.asyncio\n    async def test_30m_matrix_assembler_with_mmd(self, \n                                                assembler_30m_config, \n                                                sample_market_data, \n                                                sample_indicators):\n        \"\"\"Test 30m matrix assembler with integrated MMD processing.\"\"\"\n        # Create mock kernel with event bus\n        mock_kernel = Mock()\n        mock_event_bus = Mock()\n        mock_kernel.get_event_bus.return_value = mock_event_bus\n        assembler_30m_config['kernel'] = mock_kernel\n        \n        # Create assembler\n        assembler = MatrixAssembler30m(assembler_30m_config)\n        \n        # Verify MMD features are added\n        assert 'mmd_pc1' in assembler.feature_names\n        assert 'mmd_pc2' in assembler.feature_names\n        assert 'mmd_pc3' in assembler.feature_names\n        assert assembler.n_features == 9  # 6 original + 3 MMD\n        \n        # Create combined feature store\n        feature_store = {**sample_indicators, **sample_market_data}\n        \n        # Process multiple updates\n        for i in range(15):\n            # Slightly vary the data\n            feature_store_copy = feature_store.copy()\n            feature_store_copy['mlmi_value'] += i * 0.5\n            feature_store_copy['current_price'] += i * 0.0001\n            \n            # Simulate event\n            event = Event(\n                type=EventType.INDICATORS_READY,\n                payload=feature_store_copy,\n                source='test'\n            )\n            \n            assembler._on_indicators_ready(event)\n        \n        # Check matrix is ready\n        assert assembler.is_ready(), \"Assembler should be ready after 15 updates\"\n        \n        # Get matrix\n        matrix = assembler.get_matrix()\n        assert matrix is not None, \"Matrix should not be None\"\n        assert matrix.shape == (15, 9), f\"Expected shape (15, 9), got {matrix.shape}\"\n        \n        # Verify MMD components are included\n        mmd_pc1_values = matrix[:, 6]  # mmd_pc1 column\n        mmd_pc2_values = matrix[:, 7]  # mmd_pc2 column\n        mmd_pc3_values = matrix[:, 8]  # mmd_pc3 column\n        \n        # Check that MMD values are not all zeros (indicating they're being calculated)\n        assert not np.allclose(mmd_pc1_values, 0), \"MMD PC1 values should not be all zeros\"\n        assert np.all(np.isfinite(mmd_pc1_values)), \"MMD PC1 values should be finite\"\n        assert np.all(np.isfinite(mmd_pc2_values)), \"MMD PC2 values should be finite\"\n        assert np.all(np.isfinite(mmd_pc3_values)), \"MMD PC3 values should be finite\"\n        \n        # Get MMD statistics\n        mmd_stats = assembler.get_mmd_statistics()\n        assert 'method' in mmd_stats\n        assert 'component_interpretation' in mmd_stats\n    \n    @pytest.mark.asyncio\n    async def test_parallel_marl_system_full_integration(self, event_bus):\n        \"\"\"Test complete parallel MARL system integration.\"\"\"\n        # Create parallel MARL system\n        marl_system = ParallelMARLSystem(event_bus)\n        \n        # Verify 8 agents are created\n        assert len(marl_system.agents) == 8\n        \n        # Count strategic and tactical agents\n        strategic_agents = [a for a in marl_system.agents if a.agent_type == \"strategic\"]\n        tactical_agents = [a for a in marl_system.agents if a.agent_type == \"tactical\"]\n        \n        assert len(strategic_agents) == 4, f\"Expected 4 strategic agents, got {len(strategic_agents)}\"\n        assert len(tactical_agents) == 4, f\"Expected 4 tactical agents, got {len(tactical_agents)}\"\n        \n        # Start the system\n        await marl_system.start()\n        assert marl_system.is_running, \"MARL system should be running\"\n        \n        # Test matrix delivery and validation\n        await asyncio.sleep(0.1)  # Let system initialize\n        \n        # Create test matrices\n        matrix_30m = np.random.randn(48, 9).astype(np.float32)  # 9 features including MMD\n        matrix_5m = np.random.randn(60, 7).astype(np.float32)\n        \n        # Publish matrix events\n        event_30m = Event(\n            type=EventType.MATRIX_30M_READY,\n            payload={\n                'matrix': matrix_30m,\n                'timestamp': datetime.now()\n            },\n            source='test_matrix_assembler_30m'\n        )\n        \n        event_5m = Event(\n            type=EventType.MATRIX_5M_READY,\n            payload={\n                'matrix': matrix_5m,\n                'timestamp': datetime.now()\n            },\n            source='test_matrix_assembler_5m'\n        )\n        \n        # Track published events\n        published_events = []\n        \n        async def capture_events(event):\n            published_events.append(event)\n        \n        # Subscribe to decision events\n        await event_bus.subscribe(EventType.STRATEGIC_DECISION, capture_events)\n        await event_bus.subscribe(EventType.TACTICAL_DECISION, capture_events)\n        await event_bus.subscribe(EventType.AGENT_ACKNOWLEDGMENT, capture_events)\n        \n        # Publish matrix events\n        await event_bus.publish(event_30m)\n        await event_bus.publish(event_5m)\n        \n        # Wait for processing\n        await asyncio.sleep(0.2)\n        \n        # Verify agents received matrices and made decisions\n        strategic_decisions = [e for e in published_events if e.type == EventType.STRATEGIC_DECISION]\n        tactical_decisions = [e for e in published_events if e.type == EventType.TACTICAL_DECISION]\n        acknowledgments = [e for e in published_events if e.type == EventType.AGENT_ACKNOWLEDGMENT]\n        \n        # Should have 4 strategic decisions (one per strategic agent)\n        assert len(strategic_decisions) == 4, f\"Expected 4 strategic decisions, got {len(strategic_decisions)}\"\n        \n        # Should have 4 tactical decisions (one per tactical agent)\n        assert len(tactical_decisions) == 4, f\"Expected 4 tactical decisions, got {len(tactical_decisions)}\"\n        \n        # Should have 8 acknowledgments (one per agent)\n        assert len(acknowledgments) == 8, f\"Expected 8 acknowledgments, got {len(acknowledgments)}\"\n        \n        # Verify decision content\n        for decision_event in strategic_decisions:\n            decision = decision_event.payload['decision']\n            assert 'agent_id' in decision\n            assert 'agent_type' in decision\n            assert decision['agent_type'] == 'strategic'\n            assert 'action' in decision\n            assert 'timeframe' in decision\n            assert decision['timeframe'] == '30m'\n        \n        for decision_event in tactical_decisions:\n            decision = decision_event.payload['decision']\n            assert 'agent_id' in decision\n            assert 'agent_type' in decision\n            assert decision['agent_type'] == 'tactical'\n            assert 'action' in decision\n            assert 'timeframe' in decision\n            assert decision['timeframe'] == '5m'\n        \n        # Test system metrics\n        metrics = marl_system.get_system_metrics()\n        assert metrics['system_status'] == 'running'\n        assert metrics['total_agents'] == 8\n        assert metrics['strategic_agents'] == 4\n        assert metrics['tactical_agents'] == 4\n        assert metrics['total_decisions'] == 8  # 4 strategic + 4 tactical\n        \n        # Test trustworthiness score\n        trustworthiness = marl_system.get_trustworthiness_score()\n        assert 0.0 <= trustworthiness <= 3.0, f\"Trustworthiness score should be 0-3, got {trustworthiness}\"\n        \n        # Stop the system\n        await marl_system.stop()\n        assert not marl_system.is_running, \"MARL system should be stopped\"\n    \n    @pytest.mark.asyncio\n    async def test_matrix_delivery_validation(self):\n        \"\"\"Test 300% trustworthy matrix delivery validation.\"\"\"\n        validator = MatrixDeliveryValidator()\n        \n        # Test valid matrix\n        valid_matrix = np.random.randn(48, 9).astype(np.float32)\n        assert validator.validate_matrix_integrity(valid_matrix, \"30m\"), \"Valid matrix should pass validation\"\n        \n        # Test invalid matrices\n        invalid_matrices = [\n            None,  # None matrix\n            np.array([]),  # Empty matrix\n            np.full((48, 9), np.inf),  # Infinite values\n            np.full((48, 9), np.nan),  # NaN values\n            np.random.randn(30, 9),  # Wrong shape\n        ]\n        \n        for invalid_matrix in invalid_matrices:\n            assert not validator.validate_matrix_integrity(invalid_matrix, \"30m\"), \\\n                f\"Invalid matrix should fail validation: {type(invalid_matrix)}\"\n        \n        # Test delivery recording\n        validator.record_delivery(\"strategic_1\", \"30m\", True, agent_ack=True)\n        validator.record_delivery(\"strategic_2\", \"30m\", True, agent_ack=False)\n        validator.record_delivery(\"tactical_1\", \"5m\", False, agent_ack=False)\n        \n        # Get delivery statistics\n        stats = validator.get_delivery_stats()\n        assert stats['total_deliveries'] == 3\n        assert stats['success_rate'] == 2/3  # 2 successful out of 3\n        assert stats['acknowledgment_rate'] == 1/3  # 1 acknowledged out of 3\n        \n        # Test agent-specific stats\n        strategic_1_stats = validator.get_delivery_stats(\"strategic_1\")\n        assert strategic_1_stats['total_deliveries'] == 1\n        assert strategic_1_stats['success_rate'] == 1.0\n        assert strategic_1_stats['acknowledgment_rate'] == 1.0\n    \n    @pytest.mark.asyncio\n    async def test_performance_benchmarks(self, event_bus):\n        \"\"\"Test system performance under load.\"\"\"\n        marl_system = ParallelMARLSystem(event_bus)\n        await marl_system.start()\n        \n        # Performance test parameters\n        n_iterations = 10\n        matrix_30m = np.random.randn(48, 9).astype(np.float32)\n        matrix_5m = np.random.randn(60, 7).astype(np.float32)\n        \n        start_time = time.perf_counter()\n        \n        # Send multiple matrix updates rapidly\n        for i in range(n_iterations):\n            event_30m = Event(\n                type=EventType.MATRIX_30M_READY,\n                payload={'matrix': matrix_30m, 'timestamp': datetime.now()},\n                source='perf_test'\n            )\n            \n            event_5m = Event(\n                type=EventType.MATRIX_5M_READY,\n                payload={'matrix': matrix_5m, 'timestamp': datetime.now()},\n                source='perf_test'\n            )\n            \n            await event_bus.publish(event_30m)\n            await event_bus.publish(event_5m)\n            \n            # Small delay to prevent overwhelming\n            await asyncio.sleep(0.01)\n        \n        # Wait for all processing to complete\n        await asyncio.sleep(1.0)\n        \n        end_time = time.perf_counter()\n        total_time = end_time - start_time\n        \n        # Get final metrics\n        metrics = marl_system.get_system_metrics()\n        \n        # Performance assertions\n        assert total_time < 5.0, f\"Processing took too long: {total_time:.2f}s\"\n        assert metrics['total_decisions'] >= n_iterations * 8, \"Not all decisions were made\"\n        \n        # Check average decision time\n        if metrics['avg_decision_time_ms'] > 0:\n            assert metrics['avg_decision_time_ms'] < 10.0, \\\n                f\"Average decision time too slow: {metrics['avg_decision_time_ms']:.2f}ms\"\n        \n        await marl_system.stop()\n    \n    @pytest.mark.asyncio\n    async def test_error_recovery(self, event_bus):\n        \"\"\"Test system recovery from errors.\"\"\"\n        marl_system = ParallelMARLSystem(event_bus)\n        await marl_system.start()\n        \n        # Send invalid matrix (should be handled gracefully)\n        invalid_event = Event(\n            type=EventType.MATRIX_30M_READY,\n            payload={'matrix': None, 'timestamp': datetime.now()},\n            source='error_test'\n        )\n        \n        await event_bus.publish(invalid_event)\n        await asyncio.sleep(0.1)\n        \n        # System should still be running\n        assert marl_system.is_running, \"System should remain running after error\"\n        \n        # Send valid matrix after error\n        valid_matrix = np.random.randn(48, 9).astype(np.float32)\n        valid_event = Event(\n            type=EventType.MATRIX_30M_READY,\n            payload={'matrix': valid_matrix, 'timestamp': datetime.now()},\n            source='recovery_test'\n        )\n        \n        published_events = []\n        \n        async def capture_events(event):\n            published_events.append(event)\n        \n        await event_bus.subscribe(EventType.STRATEGIC_DECISION, capture_events)\n        await event_bus.publish(valid_event)\n        await asyncio.sleep(0.2)\n        \n        # Should recover and process valid matrix\n        strategic_decisions = [e for e in published_events if e.type == EventType.STRATEGIC_DECISION]\n        assert len(strategic_decisions) == 4, \"System should recover and process valid matrices\"\n        \n        await marl_system.stop()\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-v\", \"-s\"])